<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AETHERIUM MANIFEST: Living Interface</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;700&family=Sarabun:wght@300;500&display=swap');

    :root {
      --void-bg: #050505;
      --color-perception: #00ffff;
      --color-empathy: #bc13fe;
      --color-decay: #a0522d;
      --color-manifest: #ffd700;
      --glass-panel: rgba(20, 20, 20, 0.7);
      --border-light: rgba(255, 255, 255, 0.15);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--void-bg);
      color: #e0e0e0;
      font-family: 'JetBrains Mono', 'Sarabun', monospace;
    }

    canvas#nervous-system {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #hud-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      width: 280px;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--border-light);
      background: var(--glass-panel);
      backdrop-filter: blur(8px);
      pointer-events: none;
    }

    .stat-row {
      margin-bottom: 12px;
    }

    .stat-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      color: #888;
      font-size: 0.75rem;
    }

    .progress-bar-container {
      height: 4px;
      border-radius: 2px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.05);
    }

    .progress-bar {
      width: 100%;
      height: 100%;
      background: var(--color-perception);
      box-shadow: 0 0 10px currentColor;
      transition: width 0.5s ease, background-color 1s ease;
    }

    .system-msg {
      margin-top: 10px;
      color: var(--color-perception);
      letter-spacing: 1px;
      text-transform: uppercase;
      font-size: 0.7rem;
    }

    #input-deck {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      display: flex;
      align-items: center;
      gap: 10px;
      width: 90%;
      max-width: 600px;
      padding: 10px;
      border: 1px solid var(--border-light);
      border-radius: 16px;
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(12px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: all 0.3s ease;
    }

    #input-deck:focus-within {
      border-color: var(--color-perception);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
    }

    .icon-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      border: none;
      border-radius: 50%;
      background: transparent;
      color: #888;
      cursor: pointer;
      transition: color 0.3s, background 0.3s;
    }

    .icon-btn:hover {
      color: var(--color-perception);
      background: rgba(255, 255, 255, 0.05);
    }

    .icon-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    #chat-input {
      flex-grow: 1;
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 1rem;
      padding: 8px;
      font-family: 'Sarabun', sans-serif;
    }

    #chat-input::placeholder {
      color: #555;
      font-style: italic;
    }

    .voice-active {
      color: var(--color-empathy) !important;
      animation: pulse-voice 1.5s infinite;
    }

    @keyframes pulse-voice {
      0% {
        box-shadow: 0 0 0 0 rgba(188, 19, 254, 0.4);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(188, 19, 254, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(188, 19, 254, 0);
      }
    }

    #file-preview {
      position: absolute;
      bottom: 70px;
      left: 0;
      display: flex;
      gap: 10px;
      padding: 0 10px;
    }

    .file-chip {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      border: 1px solid var(--color-perception);
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-perception);
      font-size: 0.8rem;
    }

    #hologram-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      z-index: 5;
      opacity: 0;
      transition: opacity 1s ease;
    }

    #hologram-text {
      color: var(--color-manifest);
      text-shadow: 0 0 20px var(--color-manifest);
      letter-spacing: 4px;
      font-size: 2rem;
      font-weight: 700;
    }

    .loading-light {
      width: 50px;
      height: 50px;
      margin: 0 auto 20px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-top: 2px solid var(--color-manifest);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .floating-button {
      position: fixed;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 30;
      border: 1px solid var(--border-light);
      border-radius: 999px;
      padding: 10px 16px;
      color: white;
      cursor: pointer;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .floating-button:hover {
      transform: translateY(-2px);
    }

    #freeze-btn {
      top: 20px;
      border-color: #00ffff;
      box-shadow: 0 0 16px rgba(0, 255, 255, 0.4);
    }

    #save-btn {
      top: 74px;
      border-color: #00ff88;
      box-shadow: 0 0 16px rgba(0, 255, 136, 0.4);
      display: none;
    }

    #erase-btn {
      top: 128px;
      border-color: #ff6688;
      box-shadow: 0 0 16px rgba(255, 102, 136, 0.4);
      display: none;
    }

    #pen-btn {
      top: 182px;
      border-color: #b68cff;
      box-shadow: 0 0 16px rgba(182, 140, 255, 0.4);
      display: none;
    }

    .mode-active {
      outline: 2px solid #fff;
    }

    .document-save-ui,
    .light-pen-ui {
      position: fixed;
      left: 20px;
      bottom: 120px;
      z-index: 40;
      width: min(360px, calc(100% - 40px));
      border: 1px solid var(--border-light);
      border-radius: 16px;
      background: rgba(12, 12, 18, 0.85);
      backdrop-filter: blur(10px);
      color: #f3f3f3;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
    }

    .save-header,
    .pen-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .save-header h3,
    .pen-header h3 {
      margin: 0;
      font-size: 0.95rem;
    }

    .close-btn {
      cursor: pointer;
      opacity: 0.7;
    }

    .format-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      padding: 12px;
    }

    .format-option {
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 10px;
      cursor: pointer;
      text-align: center;
    }

    .format-option.selected {
      border-color: var(--color-manifest);
      background: rgba(255, 215, 0, 0.08);
    }

    .save-options,
    .pen-actions,
    .brush-controls {
      display: flex;
      gap: 8px;
      padding: 0 12px 12px;
      align-items: center;
    }

    .filename-input,
    .save-button,
    .pen-actions button,
    .brush-controls input {
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.05);
      color: white;
      padding: 10px;
      font-family: inherit;
    }

    .filename-input {
      flex: 1;
    }

    .save-button,
    .pen-actions button {
      cursor: pointer;
    }

    .color-palette {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      padding: 12px;
    }

    .color-option {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      margin: 0 auto;
    }

    .color-option.selected {
      border-color: #fff;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
    }

    canvas.erase-mode {
      cursor: crosshair;
    }

    canvas.draw-mode {
      cursor: cell;
    }
  </style>
</head>
<body>
  <canvas id="nervous-system"></canvas>

  <div class="floating-button" id="freeze-btn">‚ùÑÔ∏è <span>Freeze</span></div>
  <div class="floating-button" id="save-btn">üíæ <span>Save</span></div>
  <div class="floating-button" id="erase-btn">üóëÔ∏è <span>Erase</span></div>
  <div class="floating-button" id="pen-btn">üñåÔ∏è <span>Light Pen</span></div>

  <div id="hud-overlay">
    <div class="stat-row">
      <div class="stat-label"><span>ENERGY (METABOLISM)</span> <span id="val-energy">100%</span></div>
      <div class="progress-bar-container"><div class="progress-bar" id="bar-energy"></div></div>
    </div>
    <div class="stat-row">
      <div class="stat-label"><span>ENTROPY (CHAOS)</span> <span id="val-entropy">10%</span></div>
      <div class="progress-bar-container"><div class="progress-bar" id="bar-entropy" style="background: var(--color-decay); width: 10%"></div></div>
    </div>
    <div class="system-msg" id="sys-msg">SYSTEM: AWAITING INTENT</div>
  </div>

  <div id="hologram-display">
    <div class="loading-light" id="manifest-loader" style="display: none"></div>
    <div id="hologram-text"></div>
  </div>

  <div id="input-deck">
    <input type="file" id="file-upload" hidden multiple accept=".pdf,image/*" />
    <div id="file-preview"></div>

    <button class="icon-btn" id="btn-attach" title="‡πÅ‡∏ô‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£/‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û">
      <svg viewBox="0 0 24 24"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z" /></svg>
    </button>

    <input type="text" id="chat-input" placeholder="‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏à‡∏ï‡∏à‡∏≥‡∏ô‡∏á..." />

    <button class="icon-btn" id="btn-voice" title="‡∏™‡∏ô‡∏ó‡∏ô‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á">
      <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" /><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" /></svg>
    </button>

    <button class="icon-btn" id="btn-send" title="‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•">
      <svg viewBox="0 0 24 24" style="fill: var(--color-perception)"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" /></svg>
    </button>
  </div>

  <script>
    const canvas = document.getElementById('nervous-system');
    const ctx = canvas.getContext('2d');

    const state = {
      energy: 100,
      entropy: 10,
      mode: 'IDLE'
    };

    const config = {
      particleCount: 200,
      baseSpeed: 0.8,
      colors: {
        IDLE: '#00FFFF',
        LISTENING: '#BC13FE',
        PROCESSING: '#FFD700',
        MANIFESTING: '#FFFFFF'
      }
    };

    let width;
    let height;
    let particles = [];
    let center = { x: 0, y: 0 };

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      center = { x: width / 2, y: height / 2 };
    }

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * config.baseSpeed;
        this.vy = (Math.random() - 0.5) * config.baseSpeed;
        this.size = Math.random() * 2 + 0.5;
      }

      update() {
        if (state.mode === 'MANIFESTING') {
          const dx = center.x - this.x;
          const dy = center.y - this.y;
          this.vx += dx * 0.005;
          this.vy += dy * 0.005;
          this.vx *= 0.9;
          this.vy *= 0.9;
        } else if (state.mode === 'PROCESSING') {
          const dx = this.x - center.x;
          const dy = this.y - center.y;
          this.vx += -dy * 0.001;
          this.vy += dx * 0.001;
        } else {
          this.vx += (Math.random() - 0.5) * 0.1;
          this.vy += (Math.random() - 0.5) * 0.1;
        }

        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > 5) {
          this.vx *= 0.9;
          this.vy *= 0.9;
        }

        this.x += this.vx;
        this.y += this.vy;

        if (state.mode !== 'MANIFESTING') {
          if (this.x < 0) this.x = width;
          if (this.x > width) this.x = 0;
          if (this.y < 0) this.y = height;
          if (this.y > height) this.y = 0;
        }
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = config.colors[state.mode] || '#fff';
        ctx.fill();
      }
    }

    window.addEventListener('resize', resize);
    resize();
    for (let i = 0; i < config.particleCount; i += 1) particles.push(new Particle());

    const fileInput = document.getElementById('file-upload');
    const attachBtn = document.getElementById('btn-attach');
    const voiceBtn = document.getElementById('btn-voice');
    const sendBtn = document.getElementById('btn-send');
    const chatInput = document.getElementById('chat-input');
    const sysMsg = document.getElementById('sys-msg');
    const hologram = document.getElementById('hologram-display');
    const holoText = document.getElementById('hologram-text');
    const loader = document.getElementById('manifest-loader');
    const freezeBtn = document.getElementById('freeze-btn');
    const saveBtn = document.getElementById('save-btn');
    const eraseBtn = document.getElementById('erase-btn');
    const penBtn = document.getElementById('pen-btn');

    class LightDocument {
      constructor() {
        this.currentSnapshot = null;
        this.currentFormat = 'PNG';
        this.ui = this.createDocumentUI();
      }

      createDocumentUI() {
        const docUI = document.createElement('div');
        docUI.className = 'document-save-ui';
        docUI.innerHTML = `
          <div class="save-header">
            <h3>üíæ Save Frozen Light</h3>
            <div class="close-btn" data-action="close">‚úï</div>
          </div>
          <div class="format-options">
            <div class="format-option selected" data-format="PNG"><div>üñºÔ∏è PNG</div></div>
            <div class="format-option" data-format="PDF"><div>üìÑ PDF</div></div>
          </div>
          <div class="save-options">
            <input type="text" class="filename-input" value="frozen-light" />
            <button class="save-button">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå</button>
          </div>
        `;
        docUI.style.display = 'none';
        document.body.appendChild(docUI);

        docUI.querySelector('[data-action="close"]').addEventListener('click', () => {
          docUI.style.display = 'none';
        });

        docUI.querySelectorAll('.format-option').forEach((option) => {
          option.addEventListener('click', () => {
            docUI.querySelectorAll('.format-option').forEach((e) => e.classList.remove('selected'));
            option.classList.add('selected');
            this.currentFormat = option.dataset.format;
          });
        });

        docUI.querySelector('.save-button').addEventListener('click', () => {
          const baseName = docUI.querySelector('.filename-input').value.trim() || 'frozen-light';
          if (this.currentFormat === 'PDF') {
            this.exportAsPDF(`${baseName}.pdf`);
          } else {
            this.exportAsPNG(`${baseName}.png`);
          }
        });

        return docUI;
      }

      showSaveUI(snapshot) {
        this.currentSnapshot = snapshot;
        this.ui.style.display = 'block';
      }

      renderFrozenToCanvas(scale = 1) {
        const renderCanvas = document.createElement('canvas');
        renderCanvas.width = Math.floor(width * scale);
        renderCanvas.height = Math.floor(height * scale);
        const renderCtx = renderCanvas.getContext('2d');

        const gradient = renderCtx.createLinearGradient(0, 0, renderCanvas.width, renderCanvas.height);
        gradient.addColorStop(0, '#03030c');
        gradient.addColorStop(1, '#0b1120');
        renderCtx.fillStyle = gradient;
        renderCtx.fillRect(0, 0, renderCanvas.width, renderCanvas.height);

        if (!this.currentSnapshot?.points?.length) return renderCanvas;

        this.currentSnapshot.points.forEach((point) => {
          renderCtx.beginPath();
          renderCtx.fillStyle = point.color || '#99f6ff';
          renderCtx.globalAlpha = 0.92;
          renderCtx.arc(point.x * scale, point.y * scale, (point.size + 0.8) * scale, 0, Math.PI * 2);
          renderCtx.fill();
        });

        renderCtx.globalAlpha = 1;
        renderCtx.fillStyle = 'rgba(255,255,255,0.8)';
        renderCtx.font = `${14 * scale}px JetBrains Mono`;
        renderCtx.fillText(`Aetherium Freeze ‚Ä¢ ${new Date(this.currentSnapshot.timestamp).toLocaleString()}`, 20 * scale, 30 * scale);
        return renderCanvas;
      }

      triggerDownload(href, filename) {
        const anchor = document.createElement('a');
        anchor.href = href;
        anchor.download = filename;
        anchor.click();
      }

      exportAsPNG(filename = 'frozen-light.png') {
        const imgCanvas = this.renderFrozenToCanvas(2);
        this.triggerDownload(imgCanvas.toDataURL('image/png'), filename);
        sysMsg.innerText = `SYSTEM: SAVED ${filename}`;
      }

      exportAsPDF(filename = 'frozen-light.pdf') {
        const pdfCanvas = this.renderFrozenToCanvas(2);
        const imageData = pdfCanvas.toDataURL('image/png');
        const pdfShell = `<!doctype html><html><head><title>${filename}</title><style>body{margin:0;background:#10131f;display:flex;justify-content:center;align-items:center;height:100vh;}img{max-width:95vw;max-height:95vh;}</style></head><body><img src="${imageData}" alt="Frozen light"></body></html>`;
        const blob = new Blob([pdfShell], { type: 'text/html' });
        this.triggerDownload(URL.createObjectURL(blob), filename.replace(/\.pdf$/i, '.html'));
        sysMsg.innerText = 'SYSTEM: PDF fallback exported as printable HTML snapshot';
      }
    }

    class LightPen {
      constructor() {
        this.isActive = false;
        this.isDrawing = false;
        this.brushSize = 2;
        this.currentColor = '#00ffff';
        this.ui = this.createPenUI();
        this.target = null;
      }

      createPenUI() {
        const ui = document.createElement('div');
        ui.className = 'light-pen-ui';
        ui.style.display = 'none';
        const palette = ['#ff0000', '#00ff88', '#00aaff', '#ffd700', '#ffffff', '#ff00dd', '#00ffff', '#ff8844', '#b68cff', '#7fffd4'];
        ui.innerHTML = `
          <div class="pen-header"><h3>üñåÔ∏è Light Pen</h3><div class="close-btn" data-action="close">‚úï</div></div>
          <div class="color-palette">${palette.map((color, i) => `<div class="color-option ${i===6 ? 'selected' : ''}" data-color="${color}" style="background:${color}"></div>`).join('')}</div>
          <div class="brush-controls"><label for="brush-size">Brush</label><input id="brush-size" type="range" min="1" max="8" value="2" /></div>
          <div class="pen-actions"><button class="undo-btn">‚Ü∂ Undo</button><button class="finish-btn">‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô</button></div>`;
        document.body.appendChild(ui);

        ui.querySelectorAll('.color-option').forEach((node) => {
          node.addEventListener('click', () => {
            ui.querySelectorAll('.color-option').forEach((e) => e.classList.remove('selected'));
            node.classList.add('selected');
            this.currentColor = node.dataset.color;
          });
        });
        ui.querySelector('#brush-size').addEventListener('input', (e) => { this.brushSize = Number(e.target.value); });
        ui.querySelector('.finish-btn').addEventListener('click', () => this.finish());
        ui.querySelector('[data-action="close"]').addEventListener('click', () => this.finish());
        ui.querySelector('.undo-btn').addEventListener('click', () => this.undo());
        return ui;
      }

      activate(targetSnapshot) {
        this.target = targetSnapshot;
        this.isActive = true;
        this.ui.style.display = 'block';
        canvas.classList.add('draw-mode');
      }

      drawAt(x, y) {
        if (!this.isActive || !this.target) return;
        if (!this.target.history) this.target.history = [];
        const point = { x, y, size: this.brushSize, color: this.currentColor, drawn: true };
        this.target.points.push(point);
        this.target.history.push(point);
      }

      undo() {
        if (!this.target?.history?.length) return;
        const lastPoint = this.target.history.pop();
        const idx = this.target.points.lastIndexOf(lastPoint);
        if (idx >= 0) this.target.points.splice(idx, 1);
      }

      finish() {
        this.isActive = false;
        this.isDrawing = false;
        canvas.classList.remove('draw-mode');
        this.ui.style.display = 'none';
      }
    }

    class LightErase {
      constructor() {
        this.radius = 32;
        this.isActive = false;
      }

      toggle(active) {
        this.isActive = active;
        canvas.classList.toggle('erase-mode', active);
      }

      eraseAt(snapshot, x, y) {
        if (!snapshot?.points?.length) return;
        snapshot.points = snapshot.points.filter((point) => {
          const dx = point.x - x;
          const dy = point.y - y;
          return Math.sqrt(dx * dx + dy * dy) > this.radius;
        });
      }
    }

    class LightCrystallizer {
      constructor() {
        this.frozenStructures = [];
        this.currentFrozenIndex = -1;
      }

      startFreeze() {
        const snapshot = {
          timestamp: Date.now(),
          points: particles.map((p) => ({ x: p.x, y: p.y, size: p.size + 0.4, color: config.colors[state.mode] || '#99f6ff' })),
          metadata: { mode: state.mode, entropy: state.entropy }
        };
        this.frozenStructures.push(snapshot);
        this.currentFrozenIndex = this.frozenStructures.length - 1;
        saveBtn.style.display = 'flex';
        eraseBtn.style.display = 'flex';
        penBtn.style.display = 'flex';
        sysMsg.innerText = 'SYSTEM: LIGHT CRYSTALLIZED';
        return snapshot;
      }

      getCurrentFrozen() {
        return this.frozenStructures[this.currentFrozenIndex] || null;
      }

      drawFrozen(ctxRef) {
        this.frozenStructures.forEach((snapshot) => {
          snapshot.points.forEach((point) => {
            ctxRef.beginPath();
            ctxRef.fillStyle = point.color || '#99f6ff';
            ctxRef.globalAlpha = 0.9;
            ctxRef.arc(point.x, point.y, point.size, 0, Math.PI * 2);
            ctxRef.fill();
          });
        });
        ctxRef.globalAlpha = 1;
      }

      setupVoiceCommands(commands) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return;
        this.speechRecognizer = new SpeechRecognition();
        this.speechRecognizer.lang = 'th-TH';
        this.speechRecognizer.continuous = true;
        this.speechRecognizer.interimResults = false;
        this.speechRecognizer.onresult = (event) => {
          const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
          Object.entries(commands).forEach(([keyword, action]) => {
            if (transcript.includes(keyword)) action();
          });
        };
      }
    }

    const lightDocument = new LightDocument();
    const lightPen = new LightPen();
    const lightErase = new LightErase();
    const lightCrystallizer = new LightCrystallizer();

    const freezeVoiceCommands = {
      '‡πÅ‡∏ä‡πà‡πÅ‡∏Ç‡πá‡∏á': () => freezeBtn.click(),
      '‡∏´‡∏¢‡∏∏‡∏î‡∏ô‡∏¥‡πà‡∏á': () => freezeBtn.click(),
      freeze: () => freezeBtn.click(),
      '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å': () => saveBtn.click(),
      save: () => saveBtn.click(),
      '‡∏•‡∏ö': () => eraseBtn.click(),
      erase: () => eraseBtn.click(),
      '‡∏ß‡∏≤‡∏î': () => penBtn.click(),
      draw: () => penBtn.click()
    };
    lightCrystallizer.setupVoiceCommands(freezeVoiceCommands);

    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const preview = document.getElementById('file-preview');
      preview.innerHTML = `<div class="file-chip">üìé ${file.name}</div>`;
      sysMsg.innerText = `SYSTEM: FILE BUFFERED [${file.type}]`;
    });

    let isListening = false;
    voiceBtn.addEventListener('click', () => {
      isListening = !isListening;
      if (isListening) {
        voiceBtn.classList.add('voice-active');
        state.mode = 'LISTENING';
        sysMsg.innerText = 'SYSTEM: LISTENING TO VOICE FREQUENCY...';
        chatInput.placeholder = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á...';
      } else {
        voiceBtn.classList.remove('voice-active');
        state.mode = 'IDLE';
        sysMsg.innerText = 'SYSTEM: AWAITING INTENT';
        chatInput.placeholder = '‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏à‡∏ï‡∏à‡∏≥‡∏ô‡∏á...';
      }
    });

    freezeBtn.addEventListener('click', () => {
      lightCrystallizer.startFreeze();
      freezeBtn.classList.add('mode-active');
      setTimeout(() => freezeBtn.classList.remove('mode-active'), 600);
    });

    saveBtn.addEventListener('click', () => {
      const frozen = lightCrystallizer.getCurrentFrozen();
      if (!frozen) return;
      lightDocument.showSaveUI(frozen);
    });

    eraseBtn.addEventListener('click', () => {
      const willActivate = !lightErase.isActive;
      lightErase.toggle(willActivate);
      eraseBtn.classList.toggle('mode-active', willActivate);
      if (willActivate) {
        lightPen.finish();
        penBtn.classList.remove('mode-active');
        sysMsg.innerText = 'SYSTEM: ERASE MODE ACTIVE';
      } else {
        sysMsg.innerText = 'SYSTEM: ERASE MODE OFF';
      }
    });

    penBtn.addEventListener('click', () => {
      const frozen = lightCrystallizer.getCurrentFrozen();
      if (!frozen) return;
      const willActivate = !lightPen.isActive;
      penBtn.classList.toggle('mode-active', willActivate);
      if (willActivate) {
        lightErase.toggle(false);
        eraseBtn.classList.remove('mode-active');
        lightPen.activate(frozen);
        sysMsg.innerText = 'SYSTEM: LIGHT PEN ACTIVE';
      } else {
        lightPen.finish();
        sysMsg.innerText = 'SYSTEM: LIGHT PEN OFF';
      }
    });

    canvas.addEventListener('mousedown', (event) => {
      const frozen = lightCrystallizer.getCurrentFrozen();
      if (!frozen) return;
      if (lightErase.isActive) {
        lightErase.eraseAt(frozen, event.clientX, event.clientY);
      }
      if (lightPen.isActive) {
        lightPen.isDrawing = true;
        lightPen.drawAt(event.clientX, event.clientY);
      }
    });

    canvas.addEventListener('mousemove', (event) => {
      if (!lightPen.isActive || !lightPen.isDrawing) return;
      lightPen.drawAt(event.clientX, event.clientY);
    });

    window.addEventListener('mouseup', () => {
      lightPen.isDrawing = false;
    });

    function processIntent() {
      const text = chatInput.value.toLowerCase().trim();
      const hasFile = fileInput.files.length > 0;
      if (!text && !hasFile) return;

      state.mode = 'PROCESSING';
      sysMsg.innerText = 'SYSTEM: ANALYZING INTENT VECTORS...';
      hologram.style.opacity = 1;
      loader.style.display = 'block';
      holoText.innerText = '';

      chatInput.value = '';
      document.getElementById('file-preview').innerHTML = '';

      setTimeout(() => {
        state.mode = 'MANIFESTING';
        loader.style.display = 'none';

        if (text.includes('‡∏ó‡∏∞‡πÄ‡∏•') || text.includes('‡∏ô‡πâ‡∏≥‡∏ï‡∏Å') || text.includes('‡∏†‡∏π‡πÄ‡∏Ç‡∏≤') || text.includes('sea')) {
          holoText.innerText = `MANIFESTING: "${text.toUpperCase()}"`;
          sysMsg.innerText = 'SYSTEM: CONSTRUCTING VISUAL REALITY FROM DATA';
        } else if (hasFile) {
          holoText.innerText = 'DOCUMENT RECEIVED';
          sysMsg.innerText = 'SYSTEM: PARSING PDF STRUCTURE...';
        } else {
          holoText.innerText = 'UNDERSTOOD';
          sysMsg.innerText = 'SYSTEM: INTENT ACKNOWLEDGED';
        }

        setTimeout(() => {
          state.mode = 'IDLE';
          hologram.style.opacity = 0;
          sysMsg.innerText = 'SYSTEM: AWAITING NEW INTENT';
          particles.forEach((p) => p.reset());
        }, 4000);
      }, 2000);
    }

    sendBtn.addEventListener('click', processIntent);
    chatInput.addEventListener('keypress', (event) => {
      if (event.key === 'Enter') processIntent();
    });

    function animate() {
      ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
      ctx.fillRect(0, 0, width, height);

      particles.forEach((p) => {
        p.update();
        p.draw();
      });

      lightCrystallizer.drawFrozen(ctx);

      document.getElementById('bar-energy').style.width = `${state.energy}%`;
      document.getElementById('bar-energy').style.backgroundColor = config.colors[state.mode];
      document.getElementById('bar-entropy').style.width = `${state.entropy}%`;

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
