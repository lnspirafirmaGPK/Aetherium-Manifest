<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aetherium Genesis Manifest</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Sarabun:wght@300;500&display=swap');

    :root {
      --bg: #050505;
      --panel: rgba(12, 12, 14, 0.72);
      --line: rgba(255, 255, 255, 0.16);
      --white: #ffffff;
      --sleep: #00008b;
      --aether: #00ffff;
      --reasoning: #800080;
      --load: #ffd700;
      --critical: #dc143c;
      --decay: #a52a2a;
    }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #111 0%, var(--bg) 42%);
      color: #e8e8e8;
      font-family: 'JetBrains Mono', 'Sarabun', monospace;
    }

    #nervous-system {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: block;
    }

    .hud {
      position: fixed;
      z-index: 10;
      backdrop-filter: blur(12px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 18px 34px rgba(0,0,0,.45);
    }

    #status {
      top: 66px;
      right: 18px;
      width: 340px;
      padding: 14px;
    }

    .row {
      margin-bottom: 12px;
    }

    .row-head {
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      color: #aaa;
      margin-bottom: 4px;
      letter-spacing: .5px;
    }

    .bar-track {
      height: 4px;
      background: rgba(255,255,255,.08);
      border-radius: 999px;
      overflow: hidden;
    }

    .bar {
      height: 100%;
      width: 0;
      background: var(--aether);
      box-shadow: 0 0 12px currentColor;
      transition: width .32s ease, background-color .45s ease;
    }

    #settings-toggle {
      position: fixed;
      left: 18px;
      bottom: 18px;
      z-index: 40;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(8, 8, 10, 0.88);
      color: #fff;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 12px 20px rgba(0,0,0,.38);
    }

    #chat-toggle {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      z-index: 35;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(8, 8, 10, 0.82);
      color: #fff;
      padding: 8px 16px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
    }

    #settings-panel {
      position: fixed;
      left: 68px;
      bottom: 16px;
      z-index: 42;
      width: min(320px, calc(100vw - 24px));
      padding: 12px;
      display: none;
      font-size: 12px;
    }

    body.ui-open #settings-panel {
      display: block;
    }

    .settings-title {
      margin-bottom: 8px;
      font-weight: 700;
    }

    .window {
      resize: both;
      overflow: auto;
      min-width: 260px;
      min-height: 120px;
      max-width: min(92vw, 920px);
      max-height: 88vh;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: -6px -6px 8px;
      padding: 6px 6px 8px;
      border-bottom: 1px dashed rgba(255,255,255,.18);
      cursor: grab;
      user-select: none;
    }

    .panel-header:active {
      cursor: grabbing;
    }

    .panel-title {
      font-size: 11px;
      letter-spacing: .4px;
      color: #c7e9ff;
    }

    .panel-close {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.3);
      background: rgba(255,255,255,.06);
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
    }

    .setting-tabs {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 6px;
    }

    .tab-btn {
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(255,255,255,.06);
      color: #fff;
      padding: 6px;
      cursor: pointer;
      font-size: 10px;
    }

    .tab-btn.active { border-color: rgba(0,255,255,.8); color: #b8ffff; }

    .settings-tab { display: none; margin-top: 8px; }
    .settings-tab.active { display: block; }

    #external-url {
      width: 100%;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.06);
      color: #fff;
      border-radius: 8px;
      padding: 8px;
      font-size: 12px;
      margin: 6px 0;
    }


    .setting-group { margin-top: 10px; }

    .setting-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
      gap: 8px;
    }

    .seg {
      display: inline-flex;
      gap: 6px;
    }

    .seg button {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.08);
      color: #fff;
      border-radius: 8px;
      font-size: 11px;
      padding: 6px 10px;
      cursor: pointer;
    }

    .seg button.active {
      border-color: rgba(0,255,255,.65);
      color: #d0ffff;
    }

    #log {
      right: 18px;
      top: 284px;
      width: 380px;
      max-height: 46vh;
      padding: 14px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    #log pre {
      margin: 0;
      white-space: pre-wrap;
      color: #c5f7ff;
    }

    #conversation {
      right: 18px;
      top: calc(284px + 46vh + 12px);
      width: 380px;
      max-height: 34vh;
      padding: 12px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    .bubble {
      margin: 0 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.05);
    }

    .bubble.user { border-color: rgba(0,255,255,.45); color: #d7ffff; }
    .bubble.system { border-color: rgba(255,215,0,.35); color: #fff7cf; }

    #sources {
      margin-top: 8px;
      color: #9fd4ff;
      font-size: 11px;
    }

    #composer {
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      width: min(840px, calc(100vw - 36px));
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #compat {
      right: 18px;
      bottom: 18px;
      width: 340px;
      padding: 10px 12px;
      font-size: 11px;
    }

    #compat-frame {
      display: block;
      width: 100%;
      margin-top: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      min-height: 90px;
      object-fit: cover;
    }

    .compat-note {
      color: #b7d7ff;
      line-height: 1.4;
    }



    #blueprint {
      left: 18px;
      top: 16px;
      width: min(460px, calc(100vw - 36px));
      padding: 12px;
      font-size: 11px;
      line-height: 1.45;
      max-height: 42vh;
      overflow: auto;
    }

    .lock-badge {
      display: inline-block;
      margin-left: 8px;
      border: 1px solid rgba(0,255,255,.55);
      border-radius: 999px;
      padding: 2px 8px;
      color: #c7ffff;
      font-size: 10px;
    }

    .blueprint-meta {
      margin-top: 8px;
      color: #b8daff;
      font-size: 10px;
    }

    .blueprint-list {
      margin: 8px 0 0;
      padding-left: 16px;
      color: #dce9ff;
    }

    #composer {
      transition: transform .28s ease, opacity .28s ease;
    }

    body:not(.chat-open) #composer {
      transform: translate(-50%, 120%);
      opacity: 0;
      pointer-events: none;
    }

    #intent-input {
      width: 100%;
      border: 0;
      outline: none;
      color: white;
      font-size: 15px;
      padding: 10px 12px;
      border-radius: 9px;
      background: rgba(255,255,255,.07);
      font-family: 'Sarabun', sans-serif;
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.07);
      color: white;
      border-radius: 9px;
      padding: 10px 12px;
      cursor: pointer;
      font-family: inherit;
      transition: transform .16s ease, box-shadow .2s ease, background-color .2s ease;
    }

    .btn:focus-visible {
      outline: 2px solid rgba(0,255,255,.8);
      outline-offset: 2px;
    }

    .btn.touch-pulse {
      transform: scale(0.95);
      box-shadow: 0 0 0 8px rgba(0,255,255,.12);
    }

    #voice-btn {
      min-width: 44px;
      position: relative;
    }

    #voice-btn.voice-active {
      background: rgba(0,255,255,.2);
      border-color: rgba(0,255,255,.7);
      color: #b8ffff;
      box-shadow: 0 0 18px rgba(0,255,255,.35);
      animation: micPulse 1.2s infinite;
    }

    #voice-btn.voice-blocked {
      background: rgba(220,20,60,.2);
      border-color: rgba(220,20,60,.7);
      color: #ffd0d9;
    }

    #voice-status {
      font-size: 11px;
      color: #9fd4ff;
      min-width: 104px;
      text-align: center;
    }

    .control-strip {
      display: inline-flex;
      gap: 6px;
    }

    @keyframes micPulse {
      0% { box-shadow: 0 0 0 0 rgba(0,255,255,.36); }
      70% { box-shadow: 0 0 0 12px rgba(0,255,255,0); }
      100% { box-shadow: 0 0 0 0 rgba(0,255,255,0); }
    }

    .chip {
      display: inline-block;
      margin-right: 6px;
      margin-top: 6px;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: #ddd;
    }

    #display-page-2 {
      position: fixed;
      inset: 0;
      z-index: 9;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 20%, rgba(0,255,255,.08), transparent 38%),
                  radial-gradient(circle at 80% 80%, rgba(128,0,128,.12), transparent 42%),
                  rgba(5,5,5,.72);
      pointer-events: none;
    }

    body.display-page-2 #display-page-2 {
      display: flex;
    }

    .display2-card {
      width: min(760px, calc(100vw - 36px));
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(10,10,14,.76);
      backdrop-filter: blur(12px);
      padding: 16px;
    }

    .display2-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .display2-cell {
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 10px;
      padding: 10px;
      background: rgba(255,255,255,.04);
    }

    .mini-boxes {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 11;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mini-box {
      min-width: 130px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(8,8,10,.76);
      font-size: 11px;
      display: none;
    }

    body.show-box-1 #mini-box-1,
    body.show-box-2 #mini-box-2,
    body.show-box-3 #mini-box-3 {
      display: block;
    }

    .critical {
      border-color: var(--critical) !important;
      animation: flicker .14s infinite alternate;
    }

    @keyframes flicker {
      from { opacity: 1; box-shadow: 0 0 8px rgba(220,20,60,.6); }
      to { opacity: .75; box-shadow: 0 0 18px rgba(220,20,60,.9); }
    }
  </style>
</head>
<body>
  <canvas id="nervous-system"></canvas>
  <button id="settings-toggle" aria-label="toggle settings">âš™</button>
  <button id="chat-toggle" aria-label="toggle chat">Chat</button>

  <aside class="hud window" id="settings-panel" data-window-key="settings">
    <div class="settings-title">SETTINGS</div>
    <div class="setting-tabs" id="settings-tabs">
      <button class="tab-btn active" data-tab="display" type="button">Display</button>
      <button class="tab-btn" data-tab="panels" type="button">Panels</button>
      <button class="tab-btn" data-tab="links" type="button">Links</button>
      <button class="tab-btn" data-tab="language" type="button">Language</button>
      <button class="tab-btn" data-tab="voice" type="button">Voice</button>
    </div>

    <div class="settings-tab active" data-tab-content="display">
      <div class="setting-row">
        <span>Display Page</span>
        <div class="seg" id="display-selector">
          <button type="button" data-page="1" class="active">Page 1</button>
          <button type="button" data-page="2">Page 2</button>
        </div>
      </div>
      <div class="setting-row"><span>Mini Box #1</span><button class="btn" id="toggle-box-1" type="button">Toggle</button></div>
      <div class="setting-row"><span>Mini Box #2</span><button class="btn" id="toggle-box-2" type="button">Toggle</button></div>
      <div class="setting-row"><span>Mini Box #3</span><button class="btn" id="toggle-box-3" type="button">Toggle</button></div>
    </div>

    <div class="settings-tab" data-tab-content="panels">
      <div class="setting-row"><label><input type="checkbox" class="panel-toggle" data-target="status" checked /> Status</label></div>
      <div class="setting-row"><label><input type="checkbox" class="panel-toggle" data-target="log" checked /> Intent Log</label></div>
      <div class="setting-row"><label><input type="checkbox" class="panel-toggle" data-target="conversation" checked /> Conversation</label></div>
      <div class="setting-row"><label><input type="checkbox" class="panel-toggle" data-target="composer" checked /> Composer</label></div>
      <div class="setting-row"><label><input type="checkbox" class="panel-toggle" data-target="blueprint" checked /> Blueprint</label></div>
      <div class="setting-row"><label><input type="checkbox" class="panel-toggle" data-target="compat" checked /> Compatibility</label></div>
    </div>

    <div class="settings-tab" data-tab-content="links">
      <label for="external-url">External URL</label>
      <input id="external-url" type="url" placeholder="https://example.com/article" />
      <button class="btn" id="analyze-url-btn" type="button">Analyze URL</button>
      <div id="url-status" style="margin-top:6px;font-size:11px;color:#9fd4ff;">status: idle</div>
    </div>

    <div class="settings-tab" data-tab-content="language">
      <div class="setting-row">
        <label for="display-language">Display Language</label>
        <select id="display-language" class="btn">
          <option value="th">Thai</option>
          <option value="en">English</option>
          <option value="ja">æ—¥æœ¬èªž</option>
          <option value="es">EspaÃ±ol</option>
        </select>
      </div>
      <div class="setting-row">
        <label for="understanding-language">AI Understanding</label>
        <select id="understanding-language" class="btn">
          <option value="auto">Auto detect</option>
          <option value="th-TH">Thai</option>
          <option value="en-US">English</option>
          <option value="ja-JP">Japanese</option>
          <option value="es-ES">Spanish</option>
        </select>
      </div>
    </div>

    <div class="settings-tab" data-tab-content="voice">
      <div class="setting-row">
        <label for="voice-mode">Voice Mode</label>
        <select id="voice-mode" class="btn">
          <option value="standard">Standard</option>
          <option value="enhanced">Enhanced</option>
          <option value="thai-fallback">Thai fallback</option>
          <option value="regional">Regional</option>
        </select>
      </div>
      <div class="setting-row">
        <label><input type="checkbox" id="voice-telemetry" checked /> Enable telemetry</label>
      </div>
    </div>
  </aside>

  <aside class="hud window" id="status" data-window-key="status">
    <div class="row"><strong>AETHERBUS / GUNUI STATUS</strong></div>
    <div class="row">
      <div class="row-head"><span>FSM STATE</span><span id="state-text">IDLE</span></div>
      <span class="chip" id="shape-chip">shape: cloud</span>
      <span class="chip" id="intent-chip">intent: chat</span>
      <span class="chip" id="quality-chip">quality: auto</span>
    </div>
    <div class="row">
      <div class="row-head"><span>ENERGY</span><span id="energy-text">100%</span></div>
      <div class="bar-track"><div class="bar" id="energy-bar"></div></div>
    </div>
    <div class="row">
      <div class="row-head"><span>ENTROPY</span><span id="entropy-text">0%</span></div>
      <div class="bar-track"><div class="bar" id="entropy-bar"></div></div>
    </div>
    <div class="row">
      <div class="row-head"><span>LOAD (CPU HEAT)</span><span id="load-text">0%</span></div>
      <div class="bar-track"><div class="bar" id="load-bar"></div></div>
    </div>
  </aside>

  <aside class="hud window" id="log" data-window-key="log"><pre id="intent-json">Intent vector will appear here...</pre></aside>

  <aside class="hud window" id="conversation" data-window-key="conversation">
    <div><strong>CONVERSATION CONTEXT</strong></div>
    <div id="chat-stream"></div>
    <div id="sources">sources: none</div>
  </aside>

  <section class="hud window" id="composer" data-window-key="composer">
    <input id="intent-input" placeholder="Type an intent, e.g. urgent summary request or I feel confused and tired" />
    <button class="btn" id="voice-btn" type="button" title="Voice chat" aria-label="voice chat" aria-pressed="false">ðŸŽ¤</button>
    <span id="voice-status" aria-live="polite">voice: idle</span>
    <button class="btn" id="send-btn" type="button">Emit Intent</button>
    <button class="btn" id="nirodha-btn" type="button">Nirodha</button>
    <div class="control-strip" role="group" aria-label="freeze and export controls">
      <button class="btn" id="freeze-btn" type="button" aria-label="Freeze screen">Freeze</button>
      <button class="btn" id="draw-btn" type="button" aria-label="Draw mode">Draw</button>
      <button class="btn" id="save-btn" type="button" aria-label="Save snapshot PDF">Save</button>
      <button class="btn" id="erase-btn" type="button" aria-label="Erase all traces">Erase</button>
    </div>
  </section>



  <aside class="hud window" id="blueprint" data-window-key="blueprint">
    <div><strong>BLUEPRINT OF LIVING LIGHT</strong><span class="lock-badge">LOCKED AXIS</span></div>
    <div class="blueprint-meta" id="blueprint-meta"></div>
    <ul class="blueprint-list" id="blueprint-list"></ul>
  </aside>

  <aside class="hud window" id="compat" data-window-key="compat">
    <div><strong>COMPATIBILITY RENDER</strong></div>
    <div class="compat-note" id="compat-note">mode: realtime</div>
    <img id="compat-frame" alt="compatibility-frame" />
  </aside>

  <section id="display-page-2" aria-label="display page two">
    <div class="display2-card">
      <div><strong>DISPLAY PAGE 2</strong></div>
      <div style="margin-top:6px;color:#b8daff;font-size:12px;">This page is an auxiliary display mode that preserves all core system capabilities.</div>
      <div class="display2-grid">
        <div class="display2-cell">State: <span id="page2-state">IDLE</span></div>
        <div class="display2-cell">Energy: <span id="page2-energy">100%</span></div>
        <div class="display2-cell">Entropy: <span id="page2-entropy">0%</span></div>
      </div>
    </div>
  </section>

  <section class="mini-boxes" aria-label="mini display boxes">
    <div class="mini-box" id="mini-box-1">Mini Box 1 : System Pulse</div>
    <div class="mini-box" id="mini-box-2">Mini Box 2 : Intent Monitor</div>
    <div class="mini-box" id="mini-box-3">Mini Box 3 : Source Signals</div>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script>
    const canvas = document.getElementById('nervous-system');
    const ctx = canvas.getContext('2d');

    const palette = {
      IDLE: '#00ffff',
      LISTENING: '#00ffff',
      PROCESSING: '#800080',
      RESONATING: '#ffd700',
      NIRODHA: '#00008b',
      CRITICAL: '#dc143c',
      DECAY: '#a52a2a'
    };

    const fsm = {
      state: 'IDLE',
      energy: 100,
      entropy: 8,
      load: 5,
      shape: 'cloud',
      intentCategory: 'chat',
      turbulence: 0.18,
      particleDensity: 0.45,
      emotionalValence: 0,
      energyLevel: 0.2,
      desiredForm: 'abstract',
      sourceHints: [],
      qualityTier: 'auto',
      targetFps: 60
    };

    const refs = {
      stateText: document.getElementById('state-text'),
      energyText: document.getElementById('energy-text'),
      entropyText: document.getElementById('entropy-text'),
      loadText: document.getElementById('load-text'),
      energyBar: document.getElementById('energy-bar'),
      entropyBar: document.getElementById('entropy-bar'),
      loadBar: document.getElementById('load-bar'),
      shapeChip: document.getElementById('shape-chip'),
      intentChip: document.getElementById('intent-chip'),
      qualityChip: document.getElementById('quality-chip'),
      json: document.getElementById('intent-json'),
      status: document.getElementById('status'),
      compatNote: document.getElementById('compat-note'),
      compatFrame: document.getElementById('compat-frame'),
      chatStream: document.getElementById('chat-stream'),
      sources: document.getElementById('sources'),
      settingsToggle: document.getElementById('settings-toggle'),
      chatToggle: document.getElementById('chat-toggle'),
      displayPage2State: document.getElementById('page2-state'),
      displayPage2Energy: document.getElementById('page2-energy'),
      displayPage2Entropy: document.getElementById('page2-entropy'),
      blueprintMeta: document.getElementById('blueprint-meta'),
      blueprintList: document.getElementById('blueprint-list'),
      voiceButton: document.getElementById('voice-btn'),
      voiceStatus: document.getElementById('voice-status'),
      tabs: Array.from(document.querySelectorAll('.tab-btn')),
      tabContents: Array.from(document.querySelectorAll('.settings-tab')),
      panelToggles: Array.from(document.querySelectorAll('.panel-toggle')),
      analyzeUrlBtn: document.getElementById('analyze-url-btn'),
      externalUrl: document.getElementById('external-url'),
      urlStatus: document.getElementById('url-status'),
      displayLanguage: document.getElementById('display-language'),
      understandingLanguage: document.getElementById('understanding-language'),
      voiceMode: document.getElementById('voice-mode'),
      voiceTelemetry: document.getElementById('voice-telemetry')
    };

    const panelRegistry = {
      settings: document.getElementById('settings-panel'),
      status: document.getElementById('status'),
      log: document.getElementById('log'),
      conversation: document.getElementById('conversation'),
      composer: document.getElementById('composer'),
      blueprint: document.getElementById('blueprint'),
      compat: document.getElementById('compat')
    };

    const telemetry = {
      urlAnalyses: 0,
      voiceCommands: 0,
      panelClosed: 0,
      languageChanges: 0,
      events: []
    };

    const commandBus = (() => {
      const listeners = new Map();
      return {
        on(eventName, handler) {
          if (!listeners.has(eventName)) listeners.set(eventName, new Set());
          listeners.get(eventName).add(handler);
        },
        emit(eventName, payload = {}) {
          telemetry.events.push({ eventName, at: Date.now(), payload });
          if (telemetry.events.length > 200) telemetry.events.shift();
          const handlers = listeners.get(eventName) || [];
          handlers.forEach(handler => handler(payload));
        }
      };
    })();

    const runtimeConfig = {
      displayLanguage: 'th',
      understandingLanguage: 'auto',
      voiceMode: 'standard',
      deltaStateEnabled: true
    };

    function applyDeltaState(target, delta) {
      if (!runtimeConfig.deltaStateEnabled) return;
      Object.entries(delta).forEach(([key, value]) => {
        target[key] = value;
      });
      commandBus.emit('state:delta', { keys: Object.keys(delta) });
    }

    function setPanelVisibility(panelKey, visible) {
      const panel = panelRegistry[panelKey];
      if (!panel) return;
      panel.style.display = visible ? '' : 'none';
      const toggle = refs.panelToggles.find(item => item.dataset.target === panelKey);
      if (toggle) toggle.checked = visible;
      if (!visible) telemetry.panelClosed += 1;
    }

    function initializeSettingTabs() {
      refs.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          refs.tabs.forEach(btn => btn.classList.toggle('active', btn === tab));
          refs.tabContents.forEach(content => {
            content.classList.toggle('active', content.dataset.tabContent === tab.dataset.tab);
          });
        });
      });
    }

    function makePanelDraggable(panel) {
      const header = panel.querySelector('.panel-header');
      if (!header) return;
      let dragging = false;
      let offsetX = 0;
      let offsetY = 0;
      header.addEventListener('pointerdown', event => {
        dragging = true;
        panel.setPointerCapture(event.pointerId);
        offsetX = event.clientX - panel.offsetLeft;
        offsetY = event.clientY - panel.offsetTop;
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      });
      header.addEventListener('pointermove', event => {
        if (!dragging) return;
        panel.style.left = `${Math.max(0, event.clientX - offsetX)}px`;
        panel.style.top = `${Math.max(0, event.clientY - offsetY)}px`;
      });
      header.addEventListener('pointerup', event => {
        dragging = false;
        panel.releasePointerCapture(event.pointerId);
      });
    }

    function addPanelChrome() {
      Object.entries(panelRegistry).forEach(([key, panel]) => {
        if (!panel) return;
        const title = key.toUpperCase();
        const header = document.createElement('div');
        header.className = 'panel-header';
        header.innerHTML = `<span class="panel-title">${title}</span><button class="panel-close" type="button" aria-label="close ${title}">âœ•</button>`;
        panel.prepend(header);
        header.querySelector('.panel-close').addEventListener('click', () => setPanelVisibility(key, false));
        makePanelDraggable(panel);
      });
    }

    function translateUi(lang) {
      runtimeConfig.displayLanguage = lang;
      telemetry.languageChanges += 1;
      commandBus.emit('ui:language', { lang });
      const map = {
        th: { chat: 'Chat', emit: 'Emit Intent' },
        en: { chat: 'Chat', emit: 'Emit Intent' },
        ja: { chat: 'ãƒãƒ£ãƒƒãƒˆ', emit: 'é€ä¿¡' },
        es: { chat: 'Chat', emit: 'Emitir' }
      };
      const t = map[lang] || map.en;
      refs.chatToggle.textContent = t.chat;
      document.getElementById('send-btn').textContent = t.emit;
    }

    async function analyzeExternalUrl(url) {
      refs.urlStatus.textContent = 'status: loading...';
      try {
        const response = await fetch(url);
        const text = await response.text();
        const snippet = text.replace(/\s+/g, ' ').slice(0, 450);
        telemetry.urlAnalyses += 1;
        refs.urlStatus.textContent = 'status: analyzed';
        commandBus.emit('url:analyzed', { url, size: text.length });
        await processTranscript(`URL_ANALYSIS ${snippet}`, 'url');
      } catch (error) {
        refs.urlStatus.textContent = 'status: failed (CORS/network)';
        addBubble('system', `url analysis failed: ${error.message}`);
      }
    }


    const AETHERIUM_BLUEPRINT = Object.freeze({
      axis: 'AETHERIUM GENESIS: THE BLUEPRINT OF LIVING LIGHT',
      version: 'v1.0.0-locked',
      lockId: 'akashic-axis-001',
      core: Object.freeze([
        'Dualism: Inspira (will) + Firma (structure)',
        'PanGenesis: Git as an Akashic Record',
        'ALO JIT: driven by pure intent',
        'Intent-to-Particle Flux: intent -> force field -> living light',
        'Metabolic Transparency: color/luminance reflect system energy'
      ])
    });

    function renderBlueprintLock() {
      refs.blueprintMeta.textContent = `axis=${AETHERIUM_BLUEPRINT.axis} | version=${AETHERIUM_BLUEPRINT.version} | lock=${AETHERIUM_BLUEPRINT.lockId}`;
      refs.blueprintList.innerHTML = '';
      for (const item of AETHERIUM_BLUEPRINT.core) {
        const li = document.createElement('li');
        li.textContent = item;
        refs.blueprintList.appendChild(li);
      }
    }

    const displayButtons = Array.from(document.querySelectorAll('#display-selector button'));

    function setDisplayPage(page) {
      document.body.classList.toggle('display-page-2', page === '2');
      displayButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.page === page));
    }

    function toggleMiniBox(index) {
      document.body.classList.toggle(`show-box-${index}`);
    }

    const mouse = { x: -9999, y: -9999, active: false };
    let width = 0;
    let height = 0;
    let particles = [];
    let compatMode = false;
    let compatLastFrameAt = 0;
    let structuredAttractors = { face: [], human: [] };

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      structuredAttractors = buildStructuredAttractors();
    }

    function samplePolyline(points, stepsPerSegment = 14) {
      const samples = [];
      for (let i = 0; i < points.length - 1; i += 1) {
        const a = points[i];
        const b = points[i + 1];
        for (let s = 0; s < stepsPerSegment; s += 1) {
          const t = s / stepsPerSegment;
          samples.push({
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t,
            tx: b.x - a.x,
            ty: b.y - a.y
          });
        }
      }
      return samples;
    }

    function sampleEllipse(cx, cy, rx, ry, count) {
      const samples = [];
      for (let i = 0; i < count; i += 1) {
        const a = (i / count) * Math.PI * 2;
        samples.push({
          x: cx + Math.cos(a) * rx,
          y: cy + Math.sin(a) * ry,
          tx: -Math.sin(a) * rx,
          ty: Math.cos(a) * ry
        });
      }
      return samples;
    }

    function buildStructuredAttractors() {
      const cx = width * 0.5;
      const faceCy = height * 0.49;

      const jaw = samplePolyline([
        { x: cx - width * 0.18, y: faceCy - height * 0.03 },
        { x: cx - width * 0.14, y: faceCy + height * 0.11 },
        { x: cx - width * 0.08, y: faceCy + height * 0.2 },
        { x: cx, y: faceCy + height * 0.24 },
        { x: cx + width * 0.08, y: faceCy + height * 0.2 },
        { x: cx + width * 0.14, y: faceCy + height * 0.11 },
        { x: cx + width * 0.18, y: faceCy - height * 0.03 }
      ], 10);

      const noseBridge = samplePolyline([
        { x: cx, y: faceCy - height * 0.13 },
        { x: cx - width * 0.012, y: faceCy - height * 0.01 },
        { x: cx, y: faceCy + height * 0.08 },
        { x: cx + width * 0.025, y: faceCy + height * 0.1 },
        { x: cx - width * 0.025, y: faceCy + height * 0.1 }
      ], 12);

      const leftEye = sampleEllipse(cx - width * 0.075, faceCy - height * 0.04, width * 0.05, height * 0.022, 28);
      const rightEye = sampleEllipse(cx + width * 0.075, faceCy - height * 0.04, width * 0.05, height * 0.022, 28);
      const browL = samplePolyline([
        { x: cx - width * 0.135, y: faceCy - height * 0.09 },
        { x: cx - width * 0.08, y: faceCy - height * 0.11 },
        { x: cx - width * 0.02, y: faceCy - height * 0.095 }
      ], 10);
      const browR = samplePolyline([
        { x: cx + width * 0.02, y: faceCy - height * 0.095 },
        { x: cx + width * 0.08, y: faceCy - height * 0.11 },
        { x: cx + width * 0.135, y: faceCy - height * 0.09 }
      ], 10);

      const lipsOuter = sampleEllipse(cx, faceCy + height * 0.13, width * 0.072, height * 0.028, 40);
      const cheekFlowL = samplePolyline([
        { x: cx - width * 0.16, y: faceCy + height * 0.04 },
        { x: cx - width * 0.12, y: faceCy + height * 0.085 },
        { x: cx - width * 0.06, y: faceCy + height * 0.11 }
      ], 9);
      const cheekFlowR = samplePolyline([
        { x: cx + width * 0.06, y: faceCy + height * 0.11 },
        { x: cx + width * 0.12, y: faceCy + height * 0.085 },
        { x: cx + width * 0.16, y: faceCy + height * 0.04 }
      ], 9);

      const face = [jaw, noseBridge, leftEye, rightEye, browL, browR, lipsOuter, cheekFlowL, cheekFlowR].flat();

      const shoulderY = faceCy + height * 0.32;
      const humanFrame = samplePolyline([
        { x: cx - width * 0.12, y: shoulderY },
        { x: cx - width * 0.18, y: shoulderY + height * 0.13 },
        { x: cx - width * 0.2, y: shoulderY + height * 0.29 },
        { x: cx - width * 0.19, y: shoulderY + height * 0.4 }
      ], 12).concat(samplePolyline([
        { x: cx + width * 0.12, y: shoulderY },
        { x: cx + width * 0.18, y: shoulderY + height * 0.13 },
        { x: cx + width * 0.2, y: shoulderY + height * 0.29 },
        { x: cx + width * 0.19, y: shoulderY + height * 0.4 }
      ], 12));

      const torsoFlow = samplePolyline([
        { x: cx - width * 0.08, y: shoulderY + height * 0.03 },
        { x: cx - width * 0.06, y: shoulderY + height * 0.14 },
        { x: cx - width * 0.05, y: shoulderY + height * 0.3 },
        { x: cx - width * 0.02, y: shoulderY + height * 0.41 },
        { x: cx + width * 0.02, y: shoulderY + height * 0.41 },
        { x: cx + width * 0.05, y: shoulderY + height * 0.3 },
        { x: cx + width * 0.06, y: shoulderY + height * 0.14 },
        { x: cx + width * 0.08, y: shoulderY + height * 0.03 }
      ], 8);

      const human = face.concat(humanFrame, torsoFlow);
      return { face, human };
    }

    function nearestStructuredAttractor(type, x, y) {
      const points = structuredAttractors[type] || [];
      if (!points.length) return null;
      let minDist = Infinity;
      let nearest = points[0];
      for (const point of points) {
        const dx = point.x - x;
        const dy = point.y - y;
        const d = dx * dx + dy * dy;
        if (d < minDist) {
          minDist = d;
          nearest = point;
        }
      }
      return nearest;
    }

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 0.9;
        this.vy = (Math.random() - 0.5) * 0.9;
        this.size = 0.8 + Math.random() * 1.8;
        this.seed = Math.random();
      }

      update(t) {
        const speed = 0.15 + fsm.energyLevel * 1.8;
        const turbulence = fsm.turbulence * 1.2;

        if (fsm.shape === 'vortex') {
          const cx = width / 2;
          const cy = height / 2;
          const dx = this.x - cx;
          const dy = this.y - cy;
          const r = Math.max(24, Math.hypot(dx, dy));
          this.vx += (-dy / r) * (0.17 + turbulence);
          this.vy += (dx / r) * (0.17 + turbulence);
        } else if (fsm.shape === 'sphere') {
          const cx = width / 2;
          const cy = height / 2;
          this.vx += (cx - this.x) * 0.00045;
          this.vy += (cy - this.y) * 0.00045;
        } else if (fsm.shape === 'cube') {
          this.vx += Math.sin(this.y * 0.03 + t * 0.001) * 0.02;
          this.vy += Math.cos(this.x * 0.03 + t * 0.001) * 0.02;
        } else if (fsm.shape === 'mountain') {
          const targetX = (this.seed * width);
          const peakY = height * (0.35 + Math.abs((this.seed - 0.5) * 0.9));
          const slope = Math.abs((this.x - targetX) / (width * 0.35));
          const targetY = clamp(peakY + slope * height * 0.5, height * 0.2, height * 0.92);
          this.vx += (targetX - this.x) * 0.00035;
          this.vy += (targetY - this.y) * 0.00055;
        } else if (fsm.shape === 'river') {
          const flowY = height * (0.5 + Math.sin((this.x / width) * 8 + t * 0.0013) * 0.2);
          this.vx += 0.06 + turbulence * 0.1;
          this.vy += (flowY - this.y) * 0.0012;
        } else if (fsm.shape === 'face' || fsm.shape === 'human') {
          const nearest = nearestStructuredAttractor(fsm.shape, this.x, this.y);
          if (nearest) {
            const pull = fsm.shape === 'human' ? 0.00052 : 0.0006;
            this.vx += (nearest.x - this.x) * pull;
            this.vy += (nearest.y - this.y) * pull;

            const tangentMag = Math.max(0.001, Math.hypot(nearest.tx, nearest.ty));
            const orbit = (fsm.shape === 'human' ? 0.03 : 0.038) + turbulence * 0.028;
            this.vx += (nearest.tx / tangentMag) * orbit;
            this.vy += (nearest.ty / tangentMag) * orbit;
          }
        } else {
          this.vx += Math.sin(this.y * 0.009 + t * 0.001) * (0.03 + turbulence * 0.06);
          this.vy += Math.cos(this.x * 0.009 + t * 0.001) * (0.03 + turbulence * 0.06);
        }

        if (mouse.active && fsm.state !== 'NIRODHA') {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const dist = Math.max(1, Math.hypot(dx, dy));
          if (dist < 280) {
            const force = ((280 - dist) / 280) * 0.45;
            this.vx += (dx / dist) * force;
            this.vy += (dy / dist) * force;
            fsm.entropy = clamp(fsm.entropy + 0.03, 0, 100);
          }
        }

        this.vx *= 0.94;
        this.vy *= 0.94;
        this.x += this.vx * speed;
        this.y += this.vy * speed;

        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = palette[fsm.state] || palette.IDLE;
        ctx.globalAlpha = fsm.state === 'NIRODHA' ? 0.28 : 0.45 + Math.sin(Date.now() * 0.006) * 0.15;
        ctx.fill();
      }
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function evolveState() {
      if (drawSettings.frozen) {
        fsm.state = 'NIRODHA';
        return;
      }

      if (fsm.state === 'NIRODHA') {
        fsm.energy = clamp(fsm.energy + 0.28, 0, 100);
        fsm.load = clamp(fsm.load - 0.18, 0, 100);
        fsm.entropy = clamp(fsm.entropy - 0.2, 0, 100);
        if (fsm.energy > 96) fsm.state = 'IDLE';
        return;
      }

      fsm.energy = clamp(fsm.energy - 0.045 - fsm.energyLevel * 0.03, 0, 100);
      fsm.entropy = clamp(fsm.entropy * 0.996, 0, 100);
      fsm.load = clamp(fsm.load * 0.994, 0, 100);

      if (fsm.energy < 10 || fsm.load > 92) {
        fsm.state = 'CRITICAL';
      } else if (fsm.energy < 18) {
        fsm.state = 'DECAY';
      } else if (fsm.load > 65) {
        fsm.state = 'RESONATING';
      } else if (fsm.entropy > 45) {
        fsm.state = 'PROCESSING';
      } else {
        fsm.state = 'IDLE';
      }

      if (fsm.energy <= 1) fsm.state = 'NIRODHA';
    }


    const voicePipeline = {
      vad: null,
      listening: false,
      capturedFrames: 0,
      startedAt: 0,
      samples: [],
      speechRecognition: null,
      commandActive: false,
      commandSupported: false
    };

    const drawSettings = {
      penColor: '#ffffff',
      softMode: false,
      frozen: false
    };

    const timeline = [];

    function triggerTouchFeedback(element) {
      if (!element) return;
      element.classList.remove('touch-pulse');
      void element.offsetWidth;
      element.classList.add('touch-pulse');
      setTimeout(() => element.classList.remove('touch-pulse'), 180);
    }

    function setVoiceIndicator(mode, message) {
      refs.voiceButton.classList.toggle('voice-active', mode === 'active');
      refs.voiceButton.classList.toggle('voice-blocked', mode === 'blocked');
      refs.voiceButton.setAttribute('aria-pressed', String(mode === 'active'));
      refs.voiceStatus.textContent = `voice: ${message}`;
    }

    function markTimeline(action) {
      timeline.push({ at: Date.now(), action });
      if (timeline.length > 120) timeline.shift();
    }

    function setFreezeMode(nextFrozen) {
      drawSettings.frozen = nextFrozen;
      if (drawSettings.frozen) {
        fsm.state = 'NIRODHA';
        addBubble('system', 'freeze mode enabled');
      } else {
        fsm.state = 'IDLE';
        addBubble('system', 'draw mode resumed');
      }
      markTimeline(drawSettings.frozen ? 'freeze' : 'draw');
    }

    function eraseAll() {
      refs.chatStream.innerHTML = '';
      refs.sources.textContent = 'sources: none';
      refs.json.textContent = 'Intent vector will appear here...';
      fsm.energy = 100;
      fsm.entropy = 8;
      fsm.load = 5;
      fsm.state = 'IDLE';
      addBubble('system', 'all traces cleared');
      markTimeline('erase');
    }

    function revertLastAction() {
      const latest = timeline.pop();
      addBubble('system', latest ? `reverted: ${latest.action}` : 'no action to revert');
    }

    async function exportToPDF() {
      const jsPDF = window.jspdf && window.jspdf.jsPDF;
      if (!jsPDF) {
        addBubble('system', 'pdf export unavailable (jsPDF not loaded)');
        return;
      }

      const imageData = canvas.toDataURL('image/png');
      const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const w = doc.internal.pageSize.getWidth();
      const h = doc.internal.pageSize.getHeight();
      doc.setFillColor(5, 5, 8);
      doc.rect(0, 0, w, h, 'F');
      doc.addImage(imageData, 'PNG', 18, 18, w - 36, h - 36, undefined, 'FAST');

      const blob = doc.output('blob');
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `aetherium-snapshot-${Date.now()}.pdf`;
      link.click();
      setTimeout(() => URL.revokeObjectURL(url), 100);
      addBubble('system', 'snapshot exported to PDF');
      markTimeline('save');
    }

    function setupVoiceCommands(commands) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        setVoiceIndicator('blocked', 'unsupported');
        return;
      }

      const recognition = new SpeechRecognition();
      recognition.lang = runtimeConfig.understandingLanguage === 'auto' ? 'en-US' : runtimeConfig.understandingLanguage;
      recognition.continuous = true;
      recognition.interimResults = false;

      recognition.onresult = event => {
        const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
        addBubble('system', `voice command: ${transcript}`);
        if (refs.voiceTelemetry.checked) telemetry.voiceCommands += 1;
        commandBus.emit('voice:command', { transcript });
        Object.entries(commands).forEach(([keyword, action]) => {
          if (transcript.includes(keyword)) action();
        });
      };

      recognition.onstart = () => {
        voicePipeline.commandActive = true;
        setVoiceIndicator('active', 'listening');
      };

      recognition.onend = () => {
        if (voicePipeline.commandActive) {
          recognition.start();
          return;
        }
        setVoiceIndicator('idle', 'idle');
      };

      recognition.onerror = () => {
        setVoiceIndicator('blocked', 'blocked');
      };

      voicePipeline.speechRecognition = recognition;
      voicePipeline.commandSupported = true;
      setVoiceIndicator('idle', 'ready');
    }

    function startVoiceSystem() {
      if (!voicePipeline.commandSupported || !voicePipeline.speechRecognition) return;
      try {
        if (runtimeConfig.voiceMode === 'thai-fallback' && runtimeConfig.understandingLanguage === 'auto') {
          voicePipeline.speechRecognition.lang = 'th-TH';
        }
        voicePipeline.commandActive = true;
        voicePipeline.speechRecognition.start();
      } catch (_) {
        setVoiceIndicator('blocked', 'already on');
      }
    }

    function stopVoiceSystem() {
      if (!voicePipeline.speechRecognition) return;
      voicePipeline.commandActive = false;
      voicePipeline.speechRecognition.stop();
      setVoiceIndicator('idle', 'idle');
    }

    const INTENT_TEMPLATES = Object.freeze({
      request_creation: {
        intent_category: 'request_creation',
        emotional_valence: 0.6,
        energy_level: 0.78,
        semantic_concepts: ['creation', 'manifest', 'lightform']
      },
      analysis: {
        intent_category: 'analysis',
        emotional_valence: 0.15,
        energy_level: 0.48,
        semantic_concepts: ['analysis', 'structure', 'inference']
      },
      error_recovery: {
        intent_category: 'error_recovery',
        emotional_valence: -0.5,
        energy_level: 0.64,
        semantic_concepts: ['repair', 'stability', 'fallback']
      }
    });

    function detectGraphicsTier() {
      const cores = navigator.hardwareConcurrency || 4;
      const memory = navigator.deviceMemory || 4;
      const lowPower = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (lowPower || cores <= 4 || memory <= 4) return 'low';
      if (cores >= 12 && memory >= 8) return 'high';
      return 'medium';
    }

    function applyQualityTier(tier) {
      fsm.qualityTier = tier;
      if (tier === 'low') {
        fsm.targetFps = 30;
        fsm.particleDensity = Math.min(fsm.particleDensity, 0.5);
      } else if (tier === 'high') {
        fsm.targetFps = 60;
      } else {
        fsm.targetFps = 45;
        fsm.particleDensity = Math.min(fsm.particleDensity, 0.75);
      }
    }

    function setFrameRateActive(isActive) {
      if (!isActive) {
        fsm.targetFps = Math.min(fsm.targetFps, 24);
      } else {
        applyQualityTier(fsm.qualityTier);
      }
    }

    async function transcribeAudio(audioBlob) {
      const estimatedSeconds = Number(((audioBlob.size || 4096) / 32000).toFixed(2));
      return `[mock-stt:${estimatedSeconds}s] build a calm and clear light-state`;
    }

    async function analyzeIntentWithLLM(transcript) {
      const t = transcript.toLowerCase();
      const template = /(error|fail|critical)/.test(t)
        ? INTENT_TEMPLATES.error_recovery
        : /(analy|summar|inspect|explain|data)/.test(t)
          ? INTENT_TEMPLATES.analysis
          : INTENT_TEMPLATES.request_creation;

      const semantic = new Set(template.semantic_concepts);
      if (/(water|river|sea|stream)/.test(t)) semantic.add('flow');
      if (/(mountain)/.test(t)) semantic.add('mountain');
      if (/(face|human)/.test(t)) semantic.add('human');

      return {
        ...template,
        semantic_concepts: Array.from(semantic)
      };
    }

    function mapIntentToVisual(intent) {
      const concepts = intent.semantic_concepts || [];
      let baseShape = 'sphere';
      if (intent.intent_category === 'error_recovery') baseShape = 'cracks';
      else if (concepts.includes('mountain')) baseShape = 'mountain';
      else if (concepts.includes('flow')) baseShape = 'river';
      else if (concepts.includes('human')) baseShape = 'human';

      const warm = intent.emotional_valence >= 0 ? '#FFD166' : '#7FDBFF';

      return {
        intent_category: intent.intent_category,
        emotional_valence: intent.emotional_valence,
        energy_level: intent.energy_level,
        semantic_concepts: concepts,
        visual_parameters: {
          base_shape: baseShape,
          color_palette: warm,
          particle_density: Number(clamp(0.32 + intent.energy_level * 0.6, 0.2, 0.95).toFixed(2)),
          turbulence: Number(clamp(0.12 + intent.energy_level * 0.7, 0.08, 0.95).toFixed(2)),
          flow_direction: intent.emotional_valence >= 0 ? 'upward' : 'inward'
        }
      };
    }

    function initializeVoiceSystem(onSpeechEnd) {
      return {
        start() {
          voicePipeline.listening = true;
          voicePipeline.startedAt = performance.now();
          voicePipeline.capturedFrames = 0;
          setVoiceIndicator('active', 'capturing');
          addBubble('system', 'voice listening started (VAD mock)');
        },
        stop() {
          if (!voicePipeline.listening) return;
          voicePipeline.listening = false;
          setVoiceIndicator(voicePipeline.commandActive ? 'active' : 'idle', voicePipeline.commandActive ? 'listening' : 'idle');
          const elapsed = Math.max(600, performance.now() - voicePipeline.startedAt);
          const byteSize = Math.round((elapsed / 1000) * 32000);
          const payload = new Blob([new Uint8Array(byteSize)], { type: 'audio/wav' });
          onSpeechEnd(payload);
        }
      };
    }

    async function processTranscript(transcript, source = 'text') {
      const references = await fetchReferenceSignals(transcript);
      fsm.sourceHints = references;
      refs.sources.textContent = references.length
        ? `sources: ${references.join(' | ')}`
        : 'sources: none (offline/no match)';

      const baseIntent = await analyzeIntentWithLLM(`${transcript} ${references.join(' ')}`.trim());
      const vector = mapIntentToVisual(baseIntent);
      applyIntent(vector);
      addBubble('system', `[${source}] intent=${vector.intent_category}, form=${vector.visual_parameters.base_shape}, refs=${references.length}`);
    }

    function inferIntentVector(text) {
      const t = text.toLowerCase();
      let intentCategory = 'chat';
      if (/^(run|execute|deploy|start|stop)/.test(t)) intentCategory = 'command';
      if (/(summary|explain|what|find|search|data|request|help)/.test(t)) intentCategory = 'request';
      if (/(error|fail|broken)/.test(t)) intentCategory = 'error';

      let emotionalValence = 0;
      if (/(great|awesome|thanks)/.test(t)) emotionalValence = 0.65;
      if (/(angry|sad|confused|tired)/.test(t)) emotionalValence = -0.65;

      const urgent = /(urgent|now|asap|immediately|fast)/.test(t);
      const energyLevel = clamp((text.length / 120) + (urgent ? 0.36 : 0.08), 0, 1);

      const concepts = [];
      if (/(fire|heat|hot|critical)/.test(t)) concepts.push('fire');
      if (/(flow|water|stream)/.test(t)) concepts.push('flow');
      if (/(structure|table|schema|json|order)/.test(t)) concepts.push('structure');
      if (/(mountain|hill)/.test(t)) concepts.push('mountain');
      if (/(river|waterfall)/.test(t)) concepts.push('river');
      if (/(human|body)/.test(t)) concepts.push('human');
      if (/(face|portrait)/.test(t)) concepts.push('face');
      if (concepts.length === 0) concepts.push('balance');

      let baseShape = 'sphere';
      if (intentCategory === 'error') baseShape = 'cracks';
      else if (concepts.includes('mountain')) baseShape = 'mountain';
      else if (concepts.includes('river')) baseShape = 'river';
      else if (concepts.includes('face')) baseShape = 'face';
      else if (concepts.includes('human')) baseShape = 'human';
      else if (concepts.includes('flow')) baseShape = 'vortex';
      else if (concepts.includes('structure')) baseShape = 'cube';
      else if (energyLevel < 0.25) baseShape = 'cloud';

      return {
        intent_category: intentCategory,
        emotional_valence: Number(emotionalValence.toFixed(2)),
        energy_level: Number(energyLevel.toFixed(2)),
        semantic_concepts: concepts,
        visual_parameters: {
          base_shape: baseShape,
          turbulence: Number(clamp(0.1 + energyLevel * 0.8, 0, 1).toFixed(2)),
          particle_density: Number(clamp(0.35 + energyLevel * 0.55, 0, 1).toFixed(2))
        }
      };
    }

    function applyIntent(vector) {
      applyDeltaState(fsm, {
        intentCategory: vector.intent_category,
        energyLevel: vector.energy_level,
        turbulence: vector.visual_parameters.turbulence,
        particleDensity: vector.visual_parameters.particle_density,
        emotionalValence: vector.emotional_valence,
        desiredForm: vector.visual_parameters.base_shape,
        load: clamp(fsm.load + vector.energy_level * 38, 0, 100),
        entropy: clamp(fsm.entropy + vector.energy_level * 26, 0, 100),
        energy: clamp(fsm.energy - vector.energy_level * 9, 0, 100),
        state: 'PROCESSING'
      });

      if (vector.visual_parameters.base_shape === 'cracks') {
        fsm.shape = 'cloud';
        fsm.state = 'CRITICAL';
      } else {
        fsm.shape = vector.visual_parameters.base_shape;
      }

      const targetCount = Math.floor(220 + fsm.particleDensity * 980);
      particles = Array.from({ length: targetCount }, () => new Particle());

      refs.json.textContent = JSON.stringify(vector, null, 2);
    }

    function addBubble(role, message) {
      const p = document.createElement('p');
      p.className = `bubble ${role}`;
      p.textContent = `${role === 'user' ? 'USER' : 'SYSTEM'}: ${message}`;
      refs.chatStream.prepend(p);
      while (refs.chatStream.children.length > 10) refs.chatStream.removeChild(refs.chatStream.lastChild);
    }

    async function fetchReferenceSignals(text) {
      const q = encodeURIComponent(text.trim().slice(0, 80));
      if (!q) return [];
      try {
        const api = `https://en.wikipedia.org/w/api.php?action=opensearch&search=${q}&limit=3&namespace=0&format=json&origin=*`;
        const res = await fetch(api);
        if (!res.ok) return [];
        const data = await res.json();
        const titles = (data && data[1]) || [];
        return titles.filter(Boolean).slice(0, 3);
      } catch (_) {
        return [];
      }
    }

    async function processUserInput(text) {
      addBubble('user', text);
      fsm.state = 'LISTENING';
      await processTranscript(text, 'text');
    }

    function renderHUD() {
      refs.stateText.textContent = fsm.state;
      refs.energyText.textContent = `${Math.round(fsm.energy)}%`;
      refs.entropyText.textContent = `${Math.round(fsm.entropy)}%`;
      refs.loadText.textContent = `${Math.round(fsm.load)}%`;

      refs.energyBar.style.width = `${fsm.energy}%`;
      refs.entropyBar.style.width = `${fsm.entropy}%`;
      refs.loadBar.style.width = `${fsm.load}%`;

      refs.energyBar.style.backgroundColor = palette[fsm.state] || palette.IDLE;
      refs.entropyBar.style.backgroundColor = '#00ffff';
      refs.loadBar.style.backgroundColor = fsm.load > 65 ? '#ffd700' : '#ffffff';

      refs.shapeChip.textContent = `shape: ${fsm.shape}`;
      refs.intentChip.textContent = `intent: ${fsm.intentCategory}`;
      refs.qualityChip.textContent = `quality: ${fsm.qualityTier} @${fsm.targetFps}fps`;

      refs.displayPage2State.textContent = fsm.state;
      refs.displayPage2Energy.textContent = `${Math.round(fsm.energy)}%`;
      refs.displayPage2Entropy.textContent = `${Math.round(fsm.entropy)}%`;

      refs.status.classList.toggle('critical', fsm.state === 'CRITICAL');
      refs.compatNote.textContent = compatMode
        ? 'mode: compatibility (deterministic SVG snapshots every 500ms)'
        : 'mode: realtime';
    }

    function renderCompatFrame() {
      const stroke = palette[fsm.state] || palette.IDLE;
      const energy = Math.round(fsm.energy);
      const entropy = Math.round(fsm.entropy);
      const load = Math.round(fsm.load);

      const svg = `
<svg xmlns='http://www.w3.org/2000/svg' width='640' height='180' viewBox='0 0 640 180'>
  <rect width='640' height='180' fill='#050505'/>
  <text x='16' y='26' fill='#ffffff' font-size='14' font-family='monospace'>AETHERIUM COMPAT FRAME</text>
  <text x='16' y='48' fill='${stroke}' font-size='13' font-family='monospace'>STATE: ${fsm.state}</text>
  <rect x='16' y='64' width='608' height='10' fill='#222'/>
  <rect x='16' y='64' width='${(608 * energy) / 100}' height='10' fill='${stroke}'/>
  <text x='16' y='90' fill='#00ffff' font-size='12' font-family='monospace'>ENERGY ${energy}%</text>
  <text x='180' y='90' fill='#00ffff' font-size='12' font-family='monospace'>ENTROPY ${entropy}%</text>
  <text x='360' y='90' fill='#ffd700' font-size='12' font-family='monospace'>LOAD ${load}%</text>
  <text x='16' y='116' fill='#cccccc' font-size='12' font-family='monospace'>shape=${fsm.shape} intent=${fsm.intentCategory}</text>
  <circle cx='580' cy='112' r='18' fill='none' stroke='${stroke}' stroke-width='2'/>
  <circle cx='580' cy='112' r='${4 + (fsm.energyLevel * 12)}' fill='${stroke}' opacity='0.7'/>
  <text x='16' y='144' fill='#9db5ff' font-size='11' font-family='monospace'>Designed for low-feature / unstable headless environments.</text>
</svg>`;
      refs.compatFrame.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
    }

    function detectCompatibilityMode() {
      const params = new URLSearchParams(window.location.search);
      const forceCompat = params.get('render') === 'compat';
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      compatMode = Boolean(forceCompat || reduceMotion);
      if (compatMode) {
        fsm.shape = 'sphere';
        fsm.turbulence = 0.08;
      }
    }

    function drawBackground() {
      ctx.fillStyle = 'rgba(5,5,8,0.24)';
      ctx.fillRect(0, 0, width, height);

      if (fsm.state === 'NIRODHA') {
        ctx.fillStyle = 'rgba(0, 0, 139, 0.06)';
        ctx.fillRect(0, 0, width, height);
      }
    }

    let lastFrameAt = 0;
    function tick(t) {
      const frameInterval = 1000 / Math.max(12, fsm.targetFps || 60);
      if (t - lastFrameAt < frameInterval) {
        requestAnimationFrame(tick);
        return;
      }
      lastFrameAt = t;

      drawBackground();
      evolveState();

      if (!compatMode) {
        for (const p of particles) {
          p.update(t);
          p.draw();
        }
      } else if (t - compatLastFrameAt > 500) {
        renderCompatFrame();
        compatLastFrameAt = t;
      }

      ctx.globalAlpha = 1;
      renderHUD();
      requestAnimationFrame(tick);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => {
      mouse.active = true;
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      fsm.energy = clamp(fsm.energy - 0.02, 0, 100);
      fsm.entropy = clamp(fsm.entropy + 0.03, 0, 100);
    });

    document.getElementById('send-btn').addEventListener('click', async () => {
      const input = document.getElementById('intent-input');
      const text = input.value.trim();
      if (!text) return;
      await processUserInput(text);
      input.value = '';
    });

    document.getElementById('intent-input').addEventListener('keydown', e => {
      if (e.key === 'Enter') document.getElementById('send-btn').click();
    });


    addPanelChrome();
    initializeSettingTabs();

    refs.settingsToggle.addEventListener('click', () => {
      const isOpen = document.body.classList.toggle('ui-open');
      setPanelVisibility('settings', isOpen);
    });

    displayButtons.forEach(btn => {
      btn.addEventListener('click', () => setDisplayPage(btn.dataset.page));
    });

    refs.panelToggles.forEach(toggle => {
      toggle.addEventListener('change', () => {
        setPanelVisibility(toggle.dataset.target, toggle.checked);
      });
    });

    refs.displayLanguage.addEventListener('change', event => {
      translateUi(event.target.value);
    });

    refs.understandingLanguage.addEventListener('change', event => {
      runtimeConfig.understandingLanguage = event.target.value;
      commandBus.emit('voice:language', { value: event.target.value });
    });

    refs.voiceMode.addEventListener('change', event => {
      runtimeConfig.voiceMode = event.target.value;
      commandBus.emit('voice:mode', { value: event.target.value });
    });

    refs.analyzeUrlBtn.addEventListener('click', async () => {
      const url = refs.externalUrl.value.trim();
      if (!url) return;
      await analyzeExternalUrl(url);
    });

    document.getElementById('toggle-box-1').addEventListener('click', () => toggleMiniBox(1));
    document.getElementById('toggle-box-2').addEventListener('click', () => toggleMiniBox(2));
    document.getElementById('toggle-box-3').addEventListener('click', () => toggleMiniBox(3));

    const voiceSystem = initializeVoiceSystem(async (audioBlob) => {
      fsm.state = 'PROCESSING';
      const transcript = await transcribeAudio(audioBlob);
      addBubble('user', transcript);
      await processTranscript(transcript, 'voice');
    });

    setupVoiceCommands({
      white: () => { drawSettings.penColor = '#ffffff'; addBubble('system', 'pen color: white'); markTimeline('white'); },
      black: () => { drawSettings.penColor = '#000000'; addBubble('system', 'pen color: black'); markTimeline('black'); },
      freeze: () => setFreezeMode(true),
      soft: () => { drawSettings.softMode = true; addBubble('system', 'soft draw enabled'); markTimeline('soft'); },
      save: () => { exportToPDF(); },
      etc: () => eraseAll(),
      erase: () => eraseAll(),
      rev: () => revertLastAction(),
      draw: () => setFreezeMode(false)
    });

    refs.voiceButton.addEventListener('click', () => {
      triggerTouchFeedback(refs.voiceButton);
      if (!voicePipeline.commandActive) {
        startVoiceSystem();
      } else {
        stopVoiceSystem();
      }

      if (voicePipeline.listening) {
        voiceSystem.stop();
      } else {
        voiceSystem.start();
      }
    });

    refs.chatToggle.addEventListener('click', () => {
      document.body.classList.toggle('chat-open');
    });

    document.getElementById('nirodha-btn').addEventListener('click', () => {
      setFreezeMode(true);
      fsm.shape = 'cloud';
      fsm.intentCategory = 'maintenance';
      fsm.energyLevel = 0.05;
      fsm.turbulence = 0.08;
      refs.json.textContent = JSON.stringify({
        intent_category: 'maintenance',
        emotional_valence: 0,
        energy_level: 0.05,
        semantic_concepts: ['calm', 'potentiality'],
        visual_parameters: { base_shape: 'cloud', turbulence: 0.08, particle_density: 0.38 }
      }, null, 2);
    });

    document.getElementById('freeze-btn').addEventListener('click', () => {
      triggerTouchFeedback(document.getElementById('freeze-btn'));
      setFreezeMode(true);
    });

    document.getElementById('draw-btn').addEventListener('click', () => {
      triggerTouchFeedback(document.getElementById('draw-btn'));
      setFreezeMode(false);
      drawSettings.softMode = false;
    });

    document.getElementById('save-btn').addEventListener('click', () => {
      triggerTouchFeedback(document.getElementById('save-btn'));
      exportToPDF();
    });

    document.getElementById('erase-btn').addEventListener('click', () => {
      triggerTouchFeedback(document.getElementById('erase-btn'));
      eraseAll();
    });

    document.querySelectorAll('.btn').forEach(btn => {
      btn.addEventListener('pointerdown', () => triggerTouchFeedback(btn));
    });

    document.addEventListener('visibilitychange', () => {
      setFrameRateActive(!document.hidden);
    });

    document.body.classList.remove('ui-open');
    document.body.classList.remove('chat-open');
    document.body.classList.remove('display-page-2');
    resize();
    detectCompatibilityMode();
    applyQualityTier(detectGraphicsTier());
    particles = Array.from({ length: 560 }, () => new Particle());
    renderCompatFrame();
    renderBlueprintLock();
    renderHUD();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
