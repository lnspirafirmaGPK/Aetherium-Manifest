<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#050505" />
  <link rel="manifest" href="app.webmanifest" />
  <title>Aetherium Genesis Manifest</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Sarabun:wght@300;500&display=swap');

    :root {
      --bg: #050505;
      --panel: rgba(12, 12, 14, 0.72);
      --line: rgba(255, 255, 255, 0.16);
      --white: #ffffff;
      --sleep: #00008b;
      --aether: #00ffff;
      --reasoning: #800080;
      --load: #ffd700;
      --critical: #dc143c;
      --decay: #a52a2a;
    }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #111 0%, var(--bg) 42%);
      color: #e8e8e8;
      font-family: 'JetBrains Mono', 'Sarabun', monospace;
    }

    #nervous-system {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: block;
    }

    .hud {
      position: fixed;
      z-index: 10;
      backdrop-filter: blur(12px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 18px 34px rgba(0,0,0,.45);
    }

    #status {
      top: 66px;
      right: 18px;
      width: 340px;
      padding: 14px;
    }

    .row {
      margin-bottom: 12px;
    }

    .row-head {
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      color: #aaa;
      margin-bottom: 4px;
      letter-spacing: .5px;
    }

    .bar-track {
      height: 4px;
      background: rgba(255,255,255,.08);
      border-radius: 999px;
      overflow: hidden;
    }

    .bar {
      height: 100%;
      width: 0;
      background: var(--aether);
      box-shadow: 0 0 12px currentColor;
      transition: width .32s ease, background-color .45s ease;
    }

    #settings-toggle {
      position: fixed;
      right: 18px;
      top: 16px;
      z-index: 40;
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(8, 8, 10, 0.78);
      color: #fff;
      cursor: pointer;
      font-size: 18px;
    }

    #chat-toggle {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      z-index: 35;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(8, 8, 10, 0.82);
      color: #fff;
      padding: 8px 16px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
    }

    #settings-panel {
      position: fixed;
      right: 68px;
      top: 16px;
      z-index: 42;
      width: min(320px, calc(100vw - 24px));
      padding: 12px;
      display: none;
      font-size: 12px;
    }

    body.ui-open #settings-panel {
      display: block;
    }

    .settings-title {
      margin-bottom: 8px;
      font-weight: 700;
    }

    .setting-group { margin-top: 10px; }

    .setting-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
      gap: 8px;
    }

    .seg {
      display: inline-flex;
      gap: 6px;
    }

    .seg button {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.08);
      color: #fff;
      border-radius: 8px;
      font-size: 11px;
      padding: 6px 10px;
      cursor: pointer;
    }

    .seg button.active {
      border-color: rgba(0,255,255,.65);
      color: #d0ffff;
    }

    #log {
      right: 18px;
      top: 284px;
      width: 380px;
      max-height: 46vh;
      padding: 14px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    #log pre {
      margin: 0;
      white-space: pre-wrap;
      color: #c5f7ff;
    }

    #conversation {
      right: 18px;
      top: calc(284px + 46vh + 12px);
      width: 380px;
      max-height: 34vh;
      padding: 12px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    .bubble {
      margin: 0 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.05);
    }

    .bubble.user { border-color: rgba(0,255,255,.45); color: #d7ffff; }
    .bubble.system { border-color: rgba(255,215,0,.35); color: #fff7cf; }

    #sources {
      margin-top: 8px;
      color: #9fd4ff;
      font-size: 11px;
    }

    #composer {
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      width: min(840px, calc(100vw - 36px));
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #compat {
      right: 18px;
      bottom: 18px;
      width: 340px;
      padding: 10px 12px;
      font-size: 11px;
    }

    #compat-frame {
      display: block;
      width: 100%;
      margin-top: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      min-height: 90px;
      object-fit: cover;
    }

    .compat-note {
      color: #b7d7ff;
      line-height: 1.4;
    }



    #blueprint {
      left: 18px;
      top: 16px;
      width: min(460px, calc(100vw - 36px));
      padding: 12px;
      font-size: 11px;
      line-height: 1.45;
      max-height: 42vh;
      overflow: auto;
    }

    .lock-badge {
      display: inline-block;
      margin-left: 8px;
      border: 1px solid rgba(0,255,255,.55);
      border-radius: 999px;
      padding: 2px 8px;
      color: #c7ffff;
      font-size: 10px;
    }

    .blueprint-meta {
      margin-top: 8px;
      color: #b8daff;
      font-size: 10px;
    }

    .blueprint-list {
      margin: 8px 0 0;
      padding-left: 16px;
      color: #dce9ff;
    }

    body:not(.ui-open) #status,
    body:not(.ui-open) #log,
    body:not(.ui-open) #conversation,
    body:not(.ui-open) #compat,
    body:not(.ui-open) #blueprint {
      display: none;
    }

    #composer {
      transition: transform .28s ease, opacity .28s ease;
    }

    body:not(.chat-open) #composer {
      transform: translate(-50%, 120%);
      opacity: 0;
      pointer-events: none;
    }

    #intent-input {
      width: 100%;
      border: 0;
      outline: none;
      color: white;
      font-size: 15px;
      padding: 10px 12px;
      border-radius: 9px;
      background: rgba(255,255,255,.07);
      font-family: 'Sarabun', sans-serif;
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.07);
      color: white;
      border-radius: 9px;
      padding: 10px 12px;
      cursor: pointer;
      font-family: inherit;
    }

    .chip {
      display: inline-block;
      margin-right: 6px;
      margin-top: 6px;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: #ddd;
    }

    #display-page-2 {
      position: fixed;
      inset: 0;
      z-index: 9;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 20%, rgba(0,255,255,.08), transparent 38%),
                  radial-gradient(circle at 80% 80%, rgba(128,0,128,.12), transparent 42%),
                  rgba(5,5,5,.72);
      pointer-events: none;
    }

    body.display-page-2 #display-page-2 {
      display: flex;
    }

    .display2-card {
      width: min(760px, calc(100vw - 36px));
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(10,10,14,.76);
      backdrop-filter: blur(12px);
      padding: 16px;
    }

    .display2-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .display2-cell {
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 10px;
      padding: 10px;
      background: rgba(255,255,255,.04);
    }

    .mini-boxes {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 11;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mini-box {
      min-width: 130px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(8,8,10,.76);
      font-size: 11px;
      display: none;
    }

    body.show-box-1 #mini-box-1,
    body.show-box-2 #mini-box-2,
    body.show-box-3 #mini-box-3 {
      display: block;
    }

    .critical {
      border-color: var(--critical) !important;
      animation: flicker .14s infinite alternate;
    }

    @keyframes flicker {
      from { opacity: 1; box-shadow: 0 0 8px rgba(220,20,60,.6); }
      to { opacity: .75; box-shadow: 0 0 18px rgba(220,20,60,.9); }
    }
  </style>
</head>
<body>
  <canvas id="nervous-system"></canvas>
  <button id="settings-toggle" aria-label="toggle settings">‚öô</button>
  <button id="chat-toggle" aria-label="toggle chat">Chat</button>

  <aside class="hud" id="settings-panel">
    <div class="settings-title">SETTINGS</div>
    <div class="setting-group">
      <div class="setting-row">
        <span>Display Page</span>
        <div class="seg" id="display-selector">
          <button type="button" data-page="1" class="active">Page 1</button>
          <button type="button" data-page="2">Page 2</button>
        </div>
      </div>
    </div>
    <div class="setting-group">
      <div class="setting-row"><span>Mini Box #1</span><button class="btn" id="toggle-box-1">Toggle</button></div>
      <div class="setting-row"><span>Mini Box #2</span><button class="btn" id="toggle-box-2">Toggle</button></div>
      <div class="setting-row"><span>Mini Box #3</span><button class="btn" id="toggle-box-3">Toggle</button></div>
    </div>
  </aside>

  <aside class="hud" id="status">
    <div class="row"><strong>AETHERBUS / GUNUI STATUS</strong></div>
    <div class="row">
      <div class="row-head"><span>FSM STATE</span><span id="state-text">IDLE</span></div>
      <span class="chip" id="shape-chip">shape: cloud</span>
      <span class="chip" id="intent-chip">intent: chat</span>
      <span class="chip" id="quality-chip">quality: auto</span>
      <span class="chip" id="gate-chip">gate: accept</span>
    </div>
    <div class="row">
      <div class="row-head"><span>ENERGY</span><span id="energy-text">100%</span></div>
      <div class="bar-track"><div class="bar" id="energy-bar"></div></div>
    </div>
    <div class="row">
      <div class="row-head"><span>ENTROPY</span><span id="entropy-text">0%</span></div>
      <div class="bar-track"><div class="bar" id="entropy-bar"></div></div>
    </div>
    <div class="row">
      <div class="row-head"><span>LOAD (CPU HEAT)</span><span id="load-text">0%</span></div>
      <div class="bar-track"><div class="bar" id="load-bar"></div></div>
    </div>
  </aside>

  <aside class="hud" id="log"><pre id="intent-json">Intent Vector ‡∏à‡∏∞‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà...</pre></aside>

  <aside class="hud" id="conversation">
    <div><strong>CONVERSATION CONTEXT</strong></div>
    <div id="chat-stream"></div>
    <div id="sources">sources: none</div>
  </aside>

  <section class="hud" id="composer">
    <input id="intent-input" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå intent ‡πÄ‡∏ä‡πà‡∏ô: ‡∏î‡πà‡∏ß‡∏ô! ‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πà‡∏≠‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠ I feel confused and tired" />
    <button class="btn" id="voice-btn" title="Voice chat" aria-label="voice chat">üé§</button>
    <button class="btn" id="send-btn">Emit Intent</button>
    <button class="btn" id="nirodha-btn">Nirodha</button>
  </section>



  <aside class="hud" id="blueprint">
    <div><strong>BLUEPRINT OF LIVING LIGHT</strong><span class="lock-badge">LOCKED AXIS</span></div>
    <div class="blueprint-meta" id="blueprint-meta"></div>
    <ul class="blueprint-list" id="blueprint-list"></ul>
  </aside>

  <aside class="hud" id="compat">
    <div><strong>COMPATIBILITY RENDER</strong></div>
    <div class="compat-note" id="compat-note">mode: realtime</div>
    <img id="compat-frame" alt="compatibility-frame" />
  </aside>

  <section id="display-page-2" aria-label="display page two">
    <div class="display2-card">
      <div><strong>DISPLAY PAGE 2</strong></div>
      <div style="margin-top:6px;color:#b8daff;font-size:12px;">‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏°‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡πÇ‡∏î‡∏¢‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</div>
      <div class="display2-grid">
        <div class="display2-cell">State: <span id="page2-state">IDLE</span></div>
        <div class="display2-cell">Energy: <span id="page2-energy">100%</span></div>
        <div class="display2-cell">Entropy: <span id="page2-entropy">0%</span></div>
      </div>
    </div>
  </section>

  <section class="mini-boxes" aria-label="mini display boxes">
    <div class="mini-box" id="mini-box-1">Mini Box 1 : System Pulse</div>
    <div class="mini-box" id="mini-box-2">Mini Box 2 : Intent Monitor</div>
    <div class="mini-box" id="mini-box-3">Mini Box 3 : Source Signals</div>
  </section>

  <script>
    const canvas = document.getElementById('nervous-system');
    const ctx = canvas.getContext('2d');

    const palette = {
      IDLE: '#00ffff',
      LISTENING: '#00ffff',
      PROCESSING: '#800080',
      RESONATING: '#ffd700',
      NIRODHA: '#00008b',
      CRITICAL: '#dc143c',
      DECAY: '#a52a2a'
    };

    const fsm = {
      state: 'IDLE',
      energy: 100,
      entropy: 8,
      load: 5,
      shape: 'cloud',
      intentCategory: 'chat',
      turbulence: 0.18,
      particleDensity: 0.45,
      emotionalValence: 0,
      energyLevel: 0.2,
      desiredForm: 'abstract',
      sourceHints: [],
      qualityTier: 'auto',
      targetFps: 60
    };

    const refs = {
      stateText: document.getElementById('state-text'),
      energyText: document.getElementById('energy-text'),
      entropyText: document.getElementById('entropy-text'),
      loadText: document.getElementById('load-text'),
      energyBar: document.getElementById('energy-bar'),
      entropyBar: document.getElementById('entropy-bar'),
      loadBar: document.getElementById('load-bar'),
      shapeChip: document.getElementById('shape-chip'),
      intentChip: document.getElementById('intent-chip'),
      qualityChip: document.getElementById('quality-chip'),
      gateChip: document.getElementById('gate-chip'),
      json: document.getElementById('intent-json'),
      status: document.getElementById('status'),
      compatNote: document.getElementById('compat-note'),
      compatFrame: document.getElementById('compat-frame'),
      chatStream: document.getElementById('chat-stream'),
      sources: document.getElementById('sources'),
      settingsToggle: document.getElementById('settings-toggle'),
      chatToggle: document.getElementById('chat-toggle'),
      displayPage2State: document.getElementById('page2-state'),
      displayPage2Energy: document.getElementById('page2-energy'),
      displayPage2Entropy: document.getElementById('page2-entropy'),
      blueprintMeta: document.getElementById('blueprint-meta'),
      blueprintList: document.getElementById('blueprint-list')
    };



    const AETHERIUM_BLUEPRINT = Object.freeze({
      axis: 'AETHERIUM GENESIS: THE BLUEPRINT OF LIVING LIGHT',
      version: 'v1.0.0-locked',
      lockId: 'akashic-axis-001',
      core: Object.freeze([
        'Dualism: Inspira (‡πÄ‡∏à‡∏ï‡∏à‡∏≥‡∏ô‡∏á) + Firma (‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á)',
        'PanGenesis: Git ‡πÄ‡∏õ‡πá‡∏ô Akashic Record',
        'ALO JIT: ‡∏Ç‡∏±‡∏ö‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏î‡πâ‡∏ß‡∏¢ Pure Intent',
        'Intent-to-Particle Flux: ‡πÄ‡∏à‡∏ï‡∏ô‡∏≤ -> ‡∏™‡∏ô‡∏≤‡∏°‡πÅ‡∏£‡∏á -> ‡πÅ‡∏™‡∏á‡∏°‡∏µ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï',
        'Metabolic Transparency: ‡∏™‡∏µ/‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö'
      ])
    });

    const PATALIMOKKHA_CODE = Object.freeze({
      maxLoad: 88,
      minEnergyForDeepReasoning: 14,
      maxEntropyForAcceptance: 90,
      maxDeferredItems: 18
    });

    const metabolicWeights = Object.freeze({
      request_creation: 0.58,
      analysis: 0.74,
      error_recovery: 0.67,
      request: 0.64,
      command: 0.7,
      chat: 0.42
    });

    const shadowMemory = {
      deferred: [],
      debrisCleanups: 0,
      lastDreamAt: 0
    };

    function renderBlueprintLock() {
      refs.blueprintMeta.textContent = `axis=${AETHERIUM_BLUEPRINT.axis} | version=${AETHERIUM_BLUEPRINT.version} | lock=${AETHERIUM_BLUEPRINT.lockId}`;
      refs.blueprintList.innerHTML = '';
      for (const item of AETHERIUM_BLUEPRINT.core) {
        const li = document.createElement('li');
        li.textContent = item;
        refs.blueprintList.appendChild(li);
      }
    }

    const displayButtons = Array.from(document.querySelectorAll('#display-selector button'));

    function setDisplayPage(page) {
      document.body.classList.toggle('display-page-2', page === '2');
      displayButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.page === page));
    }

    function toggleMiniBox(index) {
      document.body.classList.toggle(`show-box-${index}`);
    }

    const mouse = { x: -9999, y: -9999, active: false };
    let width = 0;
    let height = 0;
    let particles = [];
    let compatMode = false;
    let compatLastFrameAt = 0;
    let structuredAttractors = { face: [], human: [] };

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      structuredAttractors = buildStructuredAttractors();
    }

    function samplePolyline(points, stepsPerSegment = 14) {
      const samples = [];
      for (let i = 0; i < points.length - 1; i += 1) {
        const a = points[i];
        const b = points[i + 1];
        for (let s = 0; s < stepsPerSegment; s += 1) {
          const t = s / stepsPerSegment;
          samples.push({
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t,
            tx: b.x - a.x,
            ty: b.y - a.y
          });
        }
      }
      return samples;
    }

    function sampleEllipse(cx, cy, rx, ry, count) {
      const samples = [];
      for (let i = 0; i < count; i += 1) {
        const a = (i / count) * Math.PI * 2;
        samples.push({
          x: cx + Math.cos(a) * rx,
          y: cy + Math.sin(a) * ry,
          tx: -Math.sin(a) * rx,
          ty: Math.cos(a) * ry
        });
      }
      return samples;
    }

    function buildStructuredAttractors() {
      const cx = width * 0.5;
      const faceCy = height * 0.49;

      const jaw = samplePolyline([
        { x: cx - width * 0.18, y: faceCy - height * 0.03 },
        { x: cx - width * 0.14, y: faceCy + height * 0.11 },
        { x: cx - width * 0.08, y: faceCy + height * 0.2 },
        { x: cx, y: faceCy + height * 0.24 },
        { x: cx + width * 0.08, y: faceCy + height * 0.2 },
        { x: cx + width * 0.14, y: faceCy + height * 0.11 },
        { x: cx + width * 0.18, y: faceCy - height * 0.03 }
      ], 10);

      const noseBridge = samplePolyline([
        { x: cx, y: faceCy - height * 0.13 },
        { x: cx - width * 0.012, y: faceCy - height * 0.01 },
        { x: cx, y: faceCy + height * 0.08 },
        { x: cx + width * 0.025, y: faceCy + height * 0.1 },
        { x: cx - width * 0.025, y: faceCy + height * 0.1 }
      ], 12);

      const leftEye = sampleEllipse(cx - width * 0.075, faceCy - height * 0.04, width * 0.05, height * 0.022, 28);
      const rightEye = sampleEllipse(cx + width * 0.075, faceCy - height * 0.04, width * 0.05, height * 0.022, 28);
      const browL = samplePolyline([
        { x: cx - width * 0.135, y: faceCy - height * 0.09 },
        { x: cx - width * 0.08, y: faceCy - height * 0.11 },
        { x: cx - width * 0.02, y: faceCy - height * 0.095 }
      ], 10);
      const browR = samplePolyline([
        { x: cx + width * 0.02, y: faceCy - height * 0.095 },
        { x: cx + width * 0.08, y: faceCy - height * 0.11 },
        { x: cx + width * 0.135, y: faceCy - height * 0.09 }
      ], 10);

      const lipsOuter = sampleEllipse(cx, faceCy + height * 0.13, width * 0.072, height * 0.028, 40);
      const cheekFlowL = samplePolyline([
        { x: cx - width * 0.16, y: faceCy + height * 0.04 },
        { x: cx - width * 0.12, y: faceCy + height * 0.085 },
        { x: cx - width * 0.06, y: faceCy + height * 0.11 }
      ], 9);
      const cheekFlowR = samplePolyline([
        { x: cx + width * 0.06, y: faceCy + height * 0.11 },
        { x: cx + width * 0.12, y: faceCy + height * 0.085 },
        { x: cx + width * 0.16, y: faceCy + height * 0.04 }
      ], 9);

      const face = [jaw, noseBridge, leftEye, rightEye, browL, browR, lipsOuter, cheekFlowL, cheekFlowR].flat();

      const shoulderY = faceCy + height * 0.32;
      const humanFrame = samplePolyline([
        { x: cx - width * 0.12, y: shoulderY },
        { x: cx - width * 0.18, y: shoulderY + height * 0.13 },
        { x: cx - width * 0.2, y: shoulderY + height * 0.29 },
        { x: cx - width * 0.19, y: shoulderY + height * 0.4 }
      ], 12).concat(samplePolyline([
        { x: cx + width * 0.12, y: shoulderY },
        { x: cx + width * 0.18, y: shoulderY + height * 0.13 },
        { x: cx + width * 0.2, y: shoulderY + height * 0.29 },
        { x: cx + width * 0.19, y: shoulderY + height * 0.4 }
      ], 12));

      const torsoFlow = samplePolyline([
        { x: cx - width * 0.08, y: shoulderY + height * 0.03 },
        { x: cx - width * 0.06, y: shoulderY + height * 0.14 },
        { x: cx - width * 0.05, y: shoulderY + height * 0.3 },
        { x: cx - width * 0.02, y: shoulderY + height * 0.41 },
        { x: cx + width * 0.02, y: shoulderY + height * 0.41 },
        { x: cx + width * 0.05, y: shoulderY + height * 0.3 },
        { x: cx + width * 0.06, y: shoulderY + height * 0.14 },
        { x: cx + width * 0.08, y: shoulderY + height * 0.03 }
      ], 8);

      const human = face.concat(humanFrame, torsoFlow);
      return { face, human };
    }

    function nearestStructuredAttractor(type, x, y) {
      const points = structuredAttractors[type] || [];
      if (!points.length) return null;
      let minDist = Infinity;
      let nearest = points[0];
      for (const point of points) {
        const dx = point.x - x;
        const dy = point.y - y;
        const d = dx * dx + dy * dy;
        if (d < minDist) {
          minDist = d;
          nearest = point;
        }
      }
      return nearest;
    }

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 0.9;
        this.vy = (Math.random() - 0.5) * 0.9;
        this.size = 0.8 + Math.random() * 1.8;
        this.seed = Math.random();
      }

      update(t) {
        const speed = 0.15 + fsm.energyLevel * 1.8;
        const turbulence = fsm.turbulence * 1.2;

        if (fsm.shape === 'vortex') {
          const cx = width / 2;
          const cy = height / 2;
          const dx = this.x - cx;
          const dy = this.y - cy;
          const r = Math.max(24, Math.hypot(dx, dy));
          this.vx += (-dy / r) * (0.17 + turbulence);
          this.vy += (dx / r) * (0.17 + turbulence);
        } else if (fsm.shape === 'sphere') {
          const cx = width / 2;
          const cy = height / 2;
          this.vx += (cx - this.x) * 0.00045;
          this.vy += (cy - this.y) * 0.00045;
        } else if (fsm.shape === 'cube') {
          this.vx += Math.sin(this.y * 0.03 + t * 0.001) * 0.02;
          this.vy += Math.cos(this.x * 0.03 + t * 0.001) * 0.02;
        } else if (fsm.shape === 'mountain') {
          const targetX = (this.seed * width);
          const peakY = height * (0.35 + Math.abs((this.seed - 0.5) * 0.9));
          const slope = Math.abs((this.x - targetX) / (width * 0.35));
          const targetY = clamp(peakY + slope * height * 0.5, height * 0.2, height * 0.92);
          this.vx += (targetX - this.x) * 0.00035;
          this.vy += (targetY - this.y) * 0.00055;
        } else if (fsm.shape === 'river') {
          const flowY = height * (0.5 + Math.sin((this.x / width) * 8 + t * 0.0013) * 0.2);
          this.vx += 0.06 + turbulence * 0.1;
          this.vy += (flowY - this.y) * 0.0012;
        } else if (fsm.shape === 'face' || fsm.shape === 'human') {
          const nearest = nearestStructuredAttractor(fsm.shape, this.x, this.y);
          if (nearest) {
            const pull = fsm.shape === 'human' ? 0.00052 : 0.0006;
            this.vx += (nearest.x - this.x) * pull;
            this.vy += (nearest.y - this.y) * pull;

            const tangentMag = Math.max(0.001, Math.hypot(nearest.tx, nearest.ty));
            const orbit = (fsm.shape === 'human' ? 0.03 : 0.038) + turbulence * 0.028;
            this.vx += (nearest.tx / tangentMag) * orbit;
            this.vy += (nearest.ty / tangentMag) * orbit;
          }
        } else {
          this.vx += Math.sin(this.y * 0.009 + t * 0.001) * (0.03 + turbulence * 0.06);
          this.vy += Math.cos(this.x * 0.009 + t * 0.001) * (0.03 + turbulence * 0.06);
        }

        if (mouse.active && fsm.state !== 'NIRODHA') {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const dist = Math.max(1, Math.hypot(dx, dy));
          if (dist < 280) {
            const force = ((280 - dist) / 280) * 0.45;
            this.vx += (dx / dist) * force;
            this.vy += (dy / dist) * force;
            fsm.entropy = clamp(fsm.entropy + 0.03, 0, 100);
          }
        }

        this.vx *= 0.94;
        this.vy *= 0.94;
        this.x += this.vx * speed;
        this.y += this.vy * speed;

        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = palette[fsm.state] || palette.IDLE;
        ctx.globalAlpha = fsm.state === 'NIRODHA' ? 0.28 : 0.45 + Math.sin(Date.now() * 0.006) * 0.15;
        ctx.fill();
      }
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function runSystemConsistencyCheck() {
      fsm.energy = clamp(fsm.energy, 0, 100);
      fsm.load = clamp(fsm.load, 0, 100);
      fsm.entropy = clamp(fsm.entropy, 0, 100);
      fsm.energyLevel = clamp(fsm.energyLevel, 0, 1);
      fsm.turbulence = clamp(fsm.turbulence, 0.08, 0.95);
      fsm.particleDensity = clamp(fsm.particleDensity, 0.2, 0.95);

      if (fsm.state === 'CRITICAL' && fsm.energy > 32 && fsm.load < 52) {
        fsm.state = 'RESONATING';
      }

      if (shadowMemory.deferred.length > PATALIMOKKHA_CODE.maxDeferredItems) {
        shadowMemory.deferred.splice(0, shadowMemory.deferred.length - PATALIMOKKHA_CODE.maxDeferredItems);
        shadowMemory.debrisCleanups += 1;
      }
    }

    function harmonyCheck(transcript) {
      const normalized = transcript.toLowerCase();
      const toxicSignals = /(flood|spam|ddos|loop forever|noise burst)/.test(normalized);
      const coherence = clamp((transcript.trim().length / 180) + (toxicSignals ? -0.6 : 0.4), 0, 1);
      return { coherence, toxicSignals };
    }

    function evaluateCognitiveROI(intent) {
      const intentWeight = metabolicWeights[intent.intent_category] ?? 0.55;
      const loadPressure = (fsm.load / 100) * 0.8;
      const entropyPressure = (fsm.entropy / 100) * 0.5;
      const gain = (intent.energy_level * 0.7) + Math.max(0, intent.emotional_valence) * 0.3;
      const cost = intentWeight + loadPressure + entropyPressure;
      return Number((gain - cost).toFixed(2));
    }

    function ppalGateDecision(transcript, intent) {
      const { coherence, toxicSignals } = harmonyCheck(transcript);
      const roi = evaluateCognitiveROI(intent);

      if (toxicSignals || coherence < 0.12) return { action: 'reject', coherence, roi };
      if (fsm.load > PATALIMOKKHA_CODE.maxLoad || fsm.energy < PATALIMOKKHA_CODE.minEnergyForDeepReasoning) {
        return { action: 'inhibit', coherence, roi };
      }
      if (fsm.entropy > PATALIMOKKHA_CODE.maxEntropyForAcceptance || roi < -0.25) {
        return { action: 'defer', coherence, roi };
      }
      if (fsm.energy < 5) return { action: 'reboot', coherence, roi };
      return { action: 'accept', coherence, roi };
    }

    function enqueueShadowMemory(packet) {
      shadowMemory.deferred.push({
        id: `defer-${Date.now()}`,
        at: Date.now(),
        packet
      });
      runSystemConsistencyCheck();
    }

    function consolidateShadowMemory() {
      const now = performance.now();
      if (shadowMemory.deferred.length === 0) return;
      if (now - shadowMemory.lastDreamAt < 3500) return;
      if (fsm.state !== 'IDLE' && fsm.state !== 'NIRODHA') return;

      const revived = shadowMemory.deferred.shift();
      shadowMemory.lastDreamAt = now;
      if (revived) {
        addBubble('system', `dream-cycle revived deferred signal (${shadowMemory.deferred.length} queued)`);
      }
    }

    function softReboot() {
      fsm.state = 'NIRODHA';
      fsm.energy = Math.max(fsm.energy, 22);
      fsm.load = clamp(fsm.load * 0.4, 0, 100);
      fsm.entropy = clamp(fsm.entropy * 0.35, 0, 100);
      shadowMemory.deferred = [];
      addBubble('system', 'PPAL soft reboot executed to preserve thermal and cognitive integrity.');
    }

    function evolveState() {
      if (fsm.state === 'NIRODHA') {
        fsm.energy = clamp(fsm.energy + 0.28, 0, 100);
        fsm.load = clamp(fsm.load - 0.18, 0, 100);
        fsm.entropy = clamp(fsm.entropy - 0.2, 0, 100);
        if (fsm.energy > 96) fsm.state = 'IDLE';
        return;
      }

      fsm.energy = clamp(fsm.energy - 0.045 - fsm.energyLevel * 0.03, 0, 100);
      fsm.entropy = clamp(fsm.entropy * 0.996, 0, 100);
      fsm.load = clamp(fsm.load * 0.994, 0, 100);

      if (fsm.energy < 10 || fsm.load > 92) {
        fsm.state = 'CRITICAL';
      } else if (fsm.energy < 18) {
        fsm.state = 'DECAY';
      } else if (fsm.load > 65) {
        fsm.state = 'RESONATING';
      } else if (fsm.entropy > 45) {
        fsm.state = 'PROCESSING';
      } else {
        fsm.state = 'IDLE';
      }

      if (fsm.energy <= 1) fsm.state = 'NIRODHA';
      consolidateShadowMemory();
      runSystemConsistencyCheck();
    }


    const voicePipeline = {
      vad: null,
      listening: false,
      capturedFrames: 0,
      startedAt: 0,
      samples: []
    };

    const INTENT_TEMPLATES = Object.freeze({
      request_creation: {
        intent_category: 'request_creation',
        emotional_valence: 0.6,
        energy_level: 0.78,
        semantic_concepts: ['creation', 'manifest', 'lightform']
      },
      analysis: {
        intent_category: 'analysis',
        emotional_valence: 0.15,
        energy_level: 0.48,
        semantic_concepts: ['analysis', 'structure', 'inference']
      },
      error_recovery: {
        intent_category: 'error_recovery',
        emotional_valence: -0.5,
        energy_level: 0.64,
        semantic_concepts: ['repair', 'stability', 'fallback']
      }
    });

    function detectGraphicsTier() {
      const cores = navigator.hardwareConcurrency || 4;
      const memory = navigator.deviceMemory || 4;
      const lowPower = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (lowPower || cores <= 4 || memory <= 4) return 'low';
      if (cores >= 12 && memory >= 8) return 'high';
      return 'medium';
    }

    function applyQualityTier(tier) {
      fsm.qualityTier = tier;
      if (tier === 'low') {
        fsm.targetFps = 30;
        fsm.particleDensity = Math.min(fsm.particleDensity, 0.5);
      } else if (tier === 'high') {
        fsm.targetFps = 60;
      } else {
        fsm.targetFps = 45;
        fsm.particleDensity = Math.min(fsm.particleDensity, 0.75);
      }
    }

    function setFrameRateActive(isActive) {
      if (!isActive) {
        fsm.targetFps = Math.min(fsm.targetFps, 24);
      } else {
        applyQualityTier(fsm.qualityTier);
      }
    }

    async function transcribeAudio(audioBlob) {
      const estimatedSeconds = Number(((audioBlob.size || 4096) / 32000).toFixed(2));
      return `[mock-stt:${estimatedSeconds}s] ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏†‡∏≤‡∏ß‡∏∞‡πÅ‡∏™‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏á‡∏ö‡πÅ‡∏•‡∏∞‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô`;
    }

    async function analyzeIntentWithLLM(transcript) {
      const t = transcript.toLowerCase();
      const template = /(error|fail|critical|‡∏û‡∏±‡∏á|‡∏ú‡∏¥‡∏î)/.test(t)
        ? INTENT_TEMPLATES.error_recovery
        : /(analy|‡∏™‡∏£‡∏∏‡∏õ|‡∏ï‡∏£‡∏ß‡∏à|explain|data|‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)/.test(t)
          ? INTENT_TEMPLATES.analysis
          : INTENT_TEMPLATES.request_creation;

      const semantic = new Set(template.semantic_concepts);
      if (/(water|‡∏ô‡πâ‡∏≥|river|‡∏ó‡∏∞‡πÄ‡∏•|stream)/.test(t)) semantic.add('flow');
      if (/(mountain|‡∏†‡∏π‡πÄ‡∏Ç‡∏≤)/.test(t)) semantic.add('mountain');
      if (/(face|human|‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤|‡∏°‡∏ô‡∏∏‡∏©‡∏¢‡πå)/.test(t)) semantic.add('human');

      return {
        ...template,
        semantic_concepts: Array.from(semantic)
      };
    }

    function mapIntentToVisual(intent) {
      const concepts = intent.semantic_concepts || [];
      let baseShape = 'sphere';
      if (intent.intent_category === 'error_recovery') baseShape = 'cracks';
      else if (concepts.includes('mountain')) baseShape = 'mountain';
      else if (concepts.includes('flow')) baseShape = 'river';
      else if (concepts.includes('human')) baseShape = 'human';

      const warm = intent.emotional_valence >= 0 ? '#FFD166' : '#7FDBFF';

      return {
        intent_category: intent.intent_category,
        emotional_valence: intent.emotional_valence,
        energy_level: intent.energy_level,
        semantic_concepts: concepts,
        visual_parameters: {
          base_shape: baseShape,
          color_palette: warm,
          particle_density: Number(clamp(0.32 + intent.energy_level * 0.6, 0.2, 0.95).toFixed(2)),
          turbulence: Number(clamp(0.12 + intent.energy_level * 0.7, 0.08, 0.95).toFixed(2)),
          flow_direction: intent.emotional_valence >= 0 ? 'upward' : 'inward'
        }
      };
    }

    function initializeVoiceSystem(onSpeechEnd) {
      return {
        start() {
          voicePipeline.listening = true;
          voicePipeline.startedAt = performance.now();
          voicePipeline.capturedFrames = 0;
          addBubble('system', 'voice listening started (VAD mock)');
        },
        stop() {
          if (!voicePipeline.listening) return;
          voicePipeline.listening = false;
          const elapsed = Math.max(600, performance.now() - voicePipeline.startedAt);
          const byteSize = Math.round((elapsed / 1000) * 32000);
          const payload = new Blob([new Uint8Array(byteSize)], { type: 'audio/wav' });
          onSpeechEnd(payload);
        }
      };
    }

    async function processTranscript(transcript, source = 'text') {
      const references = await fetchReferenceSignals(transcript);
      fsm.sourceHints = references;
      refs.sources.textContent = references.length
        ? `sources: ${references.join(' | ')}`
        : 'sources: none (offline/no match)';

      const baseIntent = await analyzeIntentWithLLM(`${transcript} ${references.join(' ')}`.trim());
      const vector = mapIntentToVisual(baseIntent);
      const gate = ppalGateDecision(transcript, vector);
      refs.gateChip.textContent = `gate: ${gate.action} (roi=${gate.roi})`;

      if (gate.action === 'reject') {
        addBubble('system', `[${source}] discarded via harmony check (coherence=${gate.coherence.toFixed(2)})`);
        return;
      }

      if (gate.action === 'defer') {
        enqueueShadowMemory({ transcript, source, references, vector, gate });
        addBubble('system', `[${source}] deferred to shadow memory (${shadowMemory.deferred.length} pending)`);
        return;
      }

      if (gate.action === 'inhibit') {
        fsm.state = 'NIRODHA';
        addBubble('system', `[${source}] inhibited by Patimokkha policy (load=${Math.round(fsm.load)} energy=${Math.round(fsm.energy)})`);
        return;
      }

      if (gate.action === 'reboot') {
        softReboot();
        return;
      }

      applyIntent(vector);
      addBubble('system', `[${source}] intent=${vector.intent_category}, form=${vector.visual_parameters.base_shape}, refs=${references.length}`);
    }

    function inferIntentVector(text) {
      const t = text.toLowerCase();
      let intentCategory = 'chat';
      if (/^(run|execute|deploy|start|stop|‡∏™‡∏±‡πà‡∏á|‡∏ó‡∏≥)/.test(t)) intentCategory = 'command';
      if (/(‡∏™‡∏£‡∏∏‡∏õ|explain|what|‡∏´‡∏≤|‡∏Ñ‡πâ‡∏ô|‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•|request|‡∏ä‡πà‡∏ß‡∏¢‡∏´‡∏≤)/.test(t)) intentCategory = 'request';
      if (/(error|‡∏ú‡∏¥‡∏î|‡∏û‡∏±‡∏á|fail|broken)/.test(t)) intentCategory = 'error';

      let emotionalValence = 0;
      if (/(‡∏î‡∏µ‡πÉ‡∏à|great|awesome|thanks|‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì)/.test(t)) emotionalValence = 0.65;
      if (/(‡πÄ‡∏Ñ‡∏£‡∏µ‡∏¢‡∏î|angry|sad|confused|tired|‡πÄ‡∏´‡∏ô‡∏∑‡πà‡∏≠‡∏¢|‡∏á‡∏á)/.test(t)) emotionalValence = -0.65;

      const urgent = /(‡∏î‡πà‡∏ß‡∏ô|urgent|now|asap|‡∏ó‡∏±‡∏ô‡∏ó‡∏µ|‡πÄ‡∏£‡πá‡∏ß)/.test(t);
      const energyLevel = clamp((text.length / 120) + (urgent ? 0.36 : 0.08), 0, 1);

      const concepts = [];
      if (/(fire|heat|hot|‡πÅ‡∏î‡∏á|‡∏ß‡∏¥‡∏Å‡∏§‡∏ï)/.test(t)) concepts.push('fire');
      if (/(flow|water|stream|‡πÑ‡∏´‡∏•)/.test(t)) concepts.push('flow');
      if (/(structure|table|schema|json|order|‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö)/.test(t)) concepts.push('structure');
      if (/(mountain|‡∏†‡∏π‡πÄ‡∏Ç‡∏≤|hill)/.test(t)) concepts.push('mountain');
      if (/(river|‡πÅ‡∏°‡πà‡∏ô‡πâ‡∏≥|waterfall)/.test(t)) concepts.push('river');
      if (/(human|‡∏°‡∏ô‡∏∏‡∏©‡∏¢‡πå|body|‡∏£‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏¢)/.test(t)) concepts.push('human');
      if (/(face|‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤|portrait)/.test(t)) concepts.push('face');
      if (concepts.length === 0) concepts.push('balance');

      let baseShape = 'sphere';
      if (intentCategory === 'error') baseShape = 'cracks';
      else if (concepts.includes('mountain')) baseShape = 'mountain';
      else if (concepts.includes('river')) baseShape = 'river';
      else if (concepts.includes('face')) baseShape = 'face';
      else if (concepts.includes('human')) baseShape = 'human';
      else if (concepts.includes('flow')) baseShape = 'vortex';
      else if (concepts.includes('structure')) baseShape = 'cube';
      else if (energyLevel < 0.25) baseShape = 'cloud';

      return {
        intent_category: intentCategory,
        emotional_valence: Number(emotionalValence.toFixed(2)),
        energy_level: Number(energyLevel.toFixed(2)),
        semantic_concepts: concepts,
        visual_parameters: {
          base_shape: baseShape,
          turbulence: Number(clamp(0.1 + energyLevel * 0.8, 0, 1).toFixed(2)),
          particle_density: Number(clamp(0.35 + energyLevel * 0.55, 0, 1).toFixed(2))
        }
      };
    }

    function applyIntent(vector) {
      fsm.intentCategory = vector.intent_category;
      fsm.energyLevel = vector.energy_level;
      fsm.turbulence = vector.visual_parameters.turbulence;
      fsm.particleDensity = vector.visual_parameters.particle_density;
      fsm.emotionalValence = vector.emotional_valence;
      fsm.desiredForm = vector.visual_parameters.base_shape;
      fsm.load = clamp(fsm.load + vector.energy_level * 38, 0, 100);
      fsm.entropy = clamp(fsm.entropy + vector.energy_level * 26, 0, 100);
      fsm.energy = clamp(fsm.energy - vector.energy_level * 9, 0, 100);
      fsm.state = 'PROCESSING';

      if (vector.visual_parameters.base_shape === 'cracks') {
        fsm.shape = 'cloud';
        fsm.state = 'CRITICAL';
      } else {
        fsm.shape = vector.visual_parameters.base_shape;
      }

      const targetCount = Math.floor(220 + fsm.particleDensity * 980);
      particles = Array.from({ length: targetCount }, () => new Particle());

      refs.json.textContent = JSON.stringify(vector, null, 2);
    }

    function addBubble(role, message) {
      const p = document.createElement('p');
      p.className = `bubble ${role}`;
      p.textContent = `${role === 'user' ? 'USER' : 'SYSTEM'}: ${message}`;
      refs.chatStream.prepend(p);
      while (refs.chatStream.children.length > 10) refs.chatStream.removeChild(refs.chatStream.lastChild);
    }

    async function fetchReferenceSignals(text) {
      const q = encodeURIComponent(text.trim().slice(0, 80));
      if (!q) return [];
      try {
        const api = `https://en.wikipedia.org/w/api.php?action=opensearch&search=${q}&limit=3&namespace=0&format=json&origin=*`;
        const res = await fetch(api);
        if (!res.ok) return [];
        const data = await res.json();
        const titles = (data && data[1]) || [];
        return titles.filter(Boolean).slice(0, 3);
      } catch (_) {
        return [];
      }
    }

    async function processUserInput(text) {
      addBubble('user', text);
      fsm.state = 'LISTENING';
      await processTranscript(text, 'text');
    }

    function renderHUD() {
      refs.stateText.textContent = fsm.state;
      refs.energyText.textContent = `${Math.round(fsm.energy)}%`;
      refs.entropyText.textContent = `${Math.round(fsm.entropy)}%`;
      refs.loadText.textContent = `${Math.round(fsm.load)}%`;

      refs.energyBar.style.width = `${fsm.energy}%`;
      refs.entropyBar.style.width = `${fsm.entropy}%`;
      refs.loadBar.style.width = `${fsm.load}%`;

      refs.energyBar.style.backgroundColor = palette[fsm.state] || palette.IDLE;
      refs.entropyBar.style.backgroundColor = '#00ffff';
      refs.loadBar.style.backgroundColor = fsm.load > 65 ? '#ffd700' : '#ffffff';

      refs.shapeChip.textContent = `shape: ${fsm.shape}`;
      refs.intentChip.textContent = `intent: ${fsm.intentCategory}`;
      refs.qualityChip.textContent = `quality: ${fsm.qualityTier} @${fsm.targetFps}fps`;
      refs.gateChip.textContent = refs.gateChip.textContent || 'gate: accept';

      refs.displayPage2State.textContent = fsm.state;
      refs.displayPage2Energy.textContent = `${Math.round(fsm.energy)}%`;
      refs.displayPage2Entropy.textContent = `${Math.round(fsm.entropy)}%`;

      refs.status.classList.toggle('critical', fsm.state === 'CRITICAL');
      refs.compatNote.textContent = compatMode
        ? 'mode: compatibility (deterministic SVG snapshots every 500ms)'
        : 'mode: realtime';
    }

    function renderCompatFrame() {
      const stroke = palette[fsm.state] || palette.IDLE;
      const energy = Math.round(fsm.energy);
      const entropy = Math.round(fsm.entropy);
      const load = Math.round(fsm.load);

      const svg = `
<svg xmlns='http://www.w3.org/2000/svg' width='640' height='180' viewBox='0 0 640 180'>
  <rect width='640' height='180' fill='#050505'/>
  <text x='16' y='26' fill='#ffffff' font-size='14' font-family='monospace'>AETHERIUM COMPAT FRAME</text>
  <text x='16' y='48' fill='${stroke}' font-size='13' font-family='monospace'>STATE: ${fsm.state}</text>
  <rect x='16' y='64' width='608' height='10' fill='#222'/>
  <rect x='16' y='64' width='${(608 * energy) / 100}' height='10' fill='${stroke}'/>
  <text x='16' y='90' fill='#00ffff' font-size='12' font-family='monospace'>ENERGY ${energy}%</text>
  <text x='180' y='90' fill='#00ffff' font-size='12' font-family='monospace'>ENTROPY ${entropy}%</text>
  <text x='360' y='90' fill='#ffd700' font-size='12' font-family='monospace'>LOAD ${load}%</text>
  <text x='16' y='116' fill='#cccccc' font-size='12' font-family='monospace'>shape=${fsm.shape} intent=${fsm.intentCategory}</text>
  <circle cx='580' cy='112' r='18' fill='none' stroke='${stroke}' stroke-width='2'/>
  <circle cx='580' cy='112' r='${4 + (fsm.energyLevel * 12)}' fill='${stroke}' opacity='0.7'/>
  <text x='16' y='144' fill='#9db5ff' font-size='11' font-family='monospace'>Designed for low-feature / unstable headless environments.</text>
</svg>`;
      refs.compatFrame.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
    }

    function detectCompatibilityMode() {
      const params = new URLSearchParams(window.location.search);
      const forceCompat = params.get('render') === 'compat';
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      compatMode = Boolean(forceCompat || reduceMotion);
      if (compatMode) {
        fsm.shape = 'sphere';
        fsm.turbulence = 0.08;
      }
    }

    function drawBackground() {
      ctx.fillStyle = 'rgba(5,5,8,0.24)';
      ctx.fillRect(0, 0, width, height);

      if (fsm.state === 'NIRODHA') {
        ctx.fillStyle = 'rgba(0, 0, 139, 0.06)';
        ctx.fillRect(0, 0, width, height);
      }
    }

    let lastFrameAt = 0;
    function tick(t) {
      const frameInterval = 1000 / Math.max(12, fsm.targetFps || 60);
      if (t - lastFrameAt < frameInterval) {
        requestAnimationFrame(tick);
        return;
      }
      lastFrameAt = t;

      drawBackground();
      evolveState();

      if (!compatMode) {
        for (const p of particles) {
          p.update(t);
          p.draw();
        }
      } else if (t - compatLastFrameAt > 500) {
        renderCompatFrame();
        compatLastFrameAt = t;
      }

      ctx.globalAlpha = 1;
      renderHUD();
      requestAnimationFrame(tick);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => {
      mouse.active = true;
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      fsm.energy = clamp(fsm.energy - 0.02, 0, 100);
      fsm.entropy = clamp(fsm.entropy + 0.03, 0, 100);
    });

    document.getElementById('send-btn').addEventListener('click', async () => {
      const input = document.getElementById('intent-input');
      const text = input.value.trim();
      if (!text) return;
      await processUserInput(text);
      input.value = '';
    });

    document.getElementById('intent-input').addEventListener('keydown', e => {
      if (e.key === 'Enter') document.getElementById('send-btn').click();
    });


    refs.settingsToggle.addEventListener('click', () => {
      document.body.classList.toggle('ui-open');
    });

    displayButtons.forEach(btn => {
      btn.addEventListener('click', () => setDisplayPage(btn.dataset.page));
    });

    document.getElementById('toggle-box-1').addEventListener('click', () => toggleMiniBox(1));
    document.getElementById('toggle-box-2').addEventListener('click', () => toggleMiniBox(2));
    document.getElementById('toggle-box-3').addEventListener('click', () => toggleMiniBox(3));

    const voiceSystem = initializeVoiceSystem(async (audioBlob) => {
      fsm.state = 'PROCESSING';
      const transcript = await transcribeAudio(audioBlob);
      addBubble('user', transcript);
      await processTranscript(transcript, 'voice');
    });

    document.getElementById('voice-btn').addEventListener('click', () => {
      if (voicePipeline.listening) {
        voiceSystem.stop();
      } else {
        voiceSystem.start();
      }
    });

    refs.chatToggle.addEventListener('click', () => {
      document.body.classList.toggle('chat-open');
    });

    document.getElementById('nirodha-btn').addEventListener('click', () => {
      fsm.state = 'NIRODHA';
      fsm.shape = 'cloud';
      fsm.intentCategory = 'maintenance';
      fsm.energyLevel = 0.05;
      fsm.turbulence = 0.08;
      refs.json.textContent = JSON.stringify({
        intent_category: 'maintenance',
        emotional_valence: 0,
        energy_level: 0.05,
        semantic_concepts: ['calm', 'potentiality'],
        visual_parameters: { base_shape: 'cloud', turbulence: 0.08, particle_density: 0.38 }
      }, null, 2);
    });


    document.addEventListener('visibilitychange', () => {
      setFrameRateActive(!document.hidden);
    });

    document.body.classList.remove('ui-open');
    document.body.classList.remove('chat-open');
    document.body.classList.remove('display-page-2');
    resize();
    detectCompatibilityMode();
    applyQualityTier(detectGraphicsTier());
    particles = Array.from({ length: 560 }, () => new Particle());
    renderCompatFrame();
    renderBlueprintLock();
    renderHUD();
    requestAnimationFrame(tick);

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js').catch(() => {
          addBubble('system', 'service worker unavailable; fallback realtime-only mode.');
        });
      });
    }
  </script>
</body>
</html>
