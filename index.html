<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aetherium Genesis Manifest</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Sarabun:wght@300;500&display=swap');

    :root {
      --bg: #050505;
      --panel: rgba(12, 12, 14, 0.72);
      --line: rgba(255, 255, 255, 0.16);
      --white: #ffffff;
      --sleep: #00008b;
      --aether: #00ffff;
      --reasoning: #800080;
      --load: #ffd700;
      --critical: #dc143c;
      --decay: #a52a2a;
    }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #111 0%, var(--bg) 42%);
      color: #e8e8e8;
      font-family: 'JetBrains Mono', 'Sarabun', monospace;
    }

    #nervous-system {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: block;
    }

    .hud {
      position: fixed;
      z-index: 10;
      backdrop-filter: blur(12px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 18px 34px rgba(0,0,0,.45);
    }

    #status {
      top: 66px;
      right: 18px;
      width: 340px;
      padding: 14px;
    }

    .row {
      margin-bottom: 12px;
    }

    .row-head {
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      color: #aaa;
      margin-bottom: 4px;
      letter-spacing: .5px;
    }

    .bar-track {
      height: 4px;
      background: rgba(255,255,255,.08);
      border-radius: 999px;
      overflow: hidden;
    }

    .bar {
      height: 100%;
      width: 0;
      background: var(--aether);
      box-shadow: 0 0 12px currentColor;
      transition: width .32s ease, background-color .45s ease;
    }

    #settings-toggle {
      position: fixed;
      right: 18px;
      top: 16px;
      z-index: 40;
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(8, 8, 10, 0.78);
      color: #fff;
      cursor: pointer;
      font-size: 18px;
    }

    #chat-toggle {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      z-index: 35;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(8, 8, 10, 0.82);
      color: #fff;
      padding: 8px 16px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
    }

    #log {
      right: 18px;
      top: 284px;
      width: 380px;
      max-height: 46vh;
      padding: 14px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    #log pre {
      margin: 0;
      white-space: pre-wrap;
      color: #c5f7ff;
    }

    #conversation {
      right: 18px;
      top: calc(284px + 46vh + 12px);
      width: 380px;
      max-height: 34vh;
      padding: 12px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    .bubble {
      margin: 0 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.05);
    }

    .bubble.user { border-color: rgba(0,255,255,.45); color: #d7ffff; }
    .bubble.system { border-color: rgba(255,215,0,.35); color: #fff7cf; }

    #sources {
      margin-top: 8px;
      color: #9fd4ff;
      font-size: 11px;
    }

    #composer {
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      width: min(840px, calc(100vw - 36px));
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #compat {
      right: 18px;
      bottom: 18px;
      width: 340px;
      padding: 10px 12px;
      font-size: 11px;
    }

    #compat-frame {
      display: block;
      width: 100%;
      margin-top: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      min-height: 90px;
      object-fit: cover;
    }

    .compat-note {
      color: #b7d7ff;
      line-height: 1.4;
    }

    body:not(.ui-open) #status,
    body:not(.ui-open) #log,
    body:not(.ui-open) #conversation,
    body:not(.ui-open) #compat {
      display: none;
    }

    #composer {
      transition: transform .28s ease, opacity .28s ease;
    }

    body:not(.chat-open) #composer {
      transform: translate(-50%, 120%);
      opacity: 0;
      pointer-events: none;
    }

    #intent-input {
      width: 100%;
      border: 0;
      outline: none;
      color: white;
      font-size: 15px;
      padding: 10px 12px;
      border-radius: 9px;
      background: rgba(255,255,255,.07);
      font-family: 'Sarabun', sans-serif;
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.07);
      color: white;
      border-radius: 9px;
      padding: 10px 12px;
      cursor: pointer;
      font-family: inherit;
    }

    .chip {
      display: inline-block;
      margin-right: 6px;
      margin-top: 6px;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: #ddd;
    }

    .critical {
      border-color: var(--critical) !important;
      animation: flicker .14s infinite alternate;
    }

    @keyframes flicker {
      from { opacity: 1; box-shadow: 0 0 8px rgba(220,20,60,.6); }
      to { opacity: .75; box-shadow: 0 0 18px rgba(220,20,60,.9); }
    }
  </style>
</head>
<body>
  <canvas id="nervous-system"></canvas>
  <button id="settings-toggle" aria-label="toggle settings">⚙</button>
  <button id="chat-toggle" aria-label="toggle chat">Chat</button>

  <aside class="hud" id="status">
    <div class="row"><strong>AETHERBUS / GUNUI STATUS</strong></div>
    <div class="row">
      <div class="row-head"><span>FSM STATE</span><span id="state-text">IDLE</span></div>
      <span class="chip" id="shape-chip">shape: cloud</span>
      <span class="chip" id="intent-chip">intent: chat</span>
    </div>
    <div class="row">
      <div class="row-head"><span>ENERGY</span><span id="energy-text">100%</span></div>
      <div class="bar-track"><div class="bar" id="energy-bar"></div></div>
    </div>
    <div class="row">
      <div class="row-head"><span>ENTROPY</span><span id="entropy-text">0%</span></div>
      <div class="bar-track"><div class="bar" id="entropy-bar"></div></div>
    </div>
    <div class="row">
      <div class="row-head"><span>LOAD (CPU HEAT)</span><span id="load-text">0%</span></div>
      <div class="bar-track"><div class="bar" id="load-bar"></div></div>
    </div>
  </aside>

  <aside class="hud" id="log"><pre id="intent-json">Intent Vector จะปรากฏที่นี่...</pre></aside>

  <aside class="hud" id="conversation">
    <div><strong>CONVERSATION CONTEXT</strong></div>
    <div id="chat-stream"></div>
    <div id="sources">sources: none</div>
  </aside>

  <section class="hud" id="composer">
    <input id="intent-input" placeholder="พิมพ์ intent เช่น: ด่วน! สรุปข้อมูลให้หน่อย หรือ I feel confused and tired" />
    <button class="btn" id="send-btn">Emit Intent</button>
    <button class="btn" id="nirodha-btn">Nirodha</button>
  </section>

  <aside class="hud" id="compat">
    <div><strong>COMPATIBILITY RENDER</strong></div>
    <div class="compat-note" id="compat-note">mode: realtime</div>
    <img id="compat-frame" alt="compatibility-frame" />
  </aside>

  <script>
    const canvas = document.getElementById('nervous-system');
    const ctx = canvas.getContext('2d');

    const palette = {
      IDLE: '#00ffff',
      LISTENING: '#00ffff',
      PROCESSING: '#800080',
      RESONATING: '#ffd700',
      NIRODHA: '#00008b',
      CRITICAL: '#dc143c',
      DECAY: '#a52a2a'
    };

    const fsm = {
      state: 'IDLE',
      energy: 100,
      entropy: 8,
      load: 5,
      shape: 'cloud',
      intentCategory: 'chat',
      turbulence: 0.18,
      particleDensity: 0.45,
      emotionalValence: 0,
      energyLevel: 0.2,
      desiredForm: 'abstract',
      sourceHints: []
    };

    const refs = {
      stateText: document.getElementById('state-text'),
      energyText: document.getElementById('energy-text'),
      entropyText: document.getElementById('entropy-text'),
      loadText: document.getElementById('load-text'),
      energyBar: document.getElementById('energy-bar'),
      entropyBar: document.getElementById('entropy-bar'),
      loadBar: document.getElementById('load-bar'),
      shapeChip: document.getElementById('shape-chip'),
      intentChip: document.getElementById('intent-chip'),
      json: document.getElementById('intent-json'),
      status: document.getElementById('status'),
      compatNote: document.getElementById('compat-note'),
      compatFrame: document.getElementById('compat-frame'),
      chatStream: document.getElementById('chat-stream'),
      sources: document.getElementById('sources'),
      settingsToggle: document.getElementById('settings-toggle'),
      chatToggle: document.getElementById('chat-toggle')
    };

    const mouse = { x: -9999, y: -9999, active: false };
    let width = 0;
    let height = 0;
    let particles = [];
    let compatMode = false;
    let compatLastFrameAt = 0;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 0.9;
        this.vy = (Math.random() - 0.5) * 0.9;
        this.size = 0.8 + Math.random() * 1.8;
        this.seed = Math.random();
      }

      update(t) {
        const speed = 0.15 + fsm.energyLevel * 1.8;
        const turbulence = fsm.turbulence * 1.2;

        if (fsm.shape === 'vortex') {
          const cx = width / 2;
          const cy = height / 2;
          const dx = this.x - cx;
          const dy = this.y - cy;
          const r = Math.max(24, Math.hypot(dx, dy));
          this.vx += (-dy / r) * (0.17 + turbulence);
          this.vy += (dx / r) * (0.17 + turbulence);
        } else if (fsm.shape === 'sphere') {
          const cx = width / 2;
          const cy = height / 2;
          this.vx += (cx - this.x) * 0.00045;
          this.vy += (cy - this.y) * 0.00045;
        } else if (fsm.shape === 'cube') {
          this.vx += Math.sin(this.y * 0.03 + t * 0.001) * 0.02;
          this.vy += Math.cos(this.x * 0.03 + t * 0.001) * 0.02;
        } else if (fsm.shape === 'mountain') {
          const targetX = (this.seed * width);
          const peakY = height * (0.35 + Math.abs((this.seed - 0.5) * 0.9));
          const slope = Math.abs((this.x - targetX) / (width * 0.35));
          const targetY = clamp(peakY + slope * height * 0.5, height * 0.2, height * 0.92);
          this.vx += (targetX - this.x) * 0.00035;
          this.vy += (targetY - this.y) * 0.00055;
        } else if (fsm.shape === 'river') {
          const flowY = height * (0.5 + Math.sin((this.x / width) * 8 + t * 0.0013) * 0.2);
          this.vx += 0.06 + turbulence * 0.1;
          this.vy += (flowY - this.y) * 0.0012;
        } else if (fsm.shape === 'face' || fsm.shape === 'human') {
          const cx = width * 0.5;
          const cy = height * 0.52;
          const phase = this.seed * Math.PI * 2;
          const r = fsm.shape === 'human' ? width * 0.14 : width * 0.12;
          const targetX = cx + Math.cos(phase) * r * (0.65 + this.seed * 0.5);
          const targetY = cy + Math.sin(phase) * r * (0.9 + this.seed * 0.35);
          this.vx += (targetX - this.x) * 0.00042;
          this.vy += (targetY - this.y) * 0.00042;
        } else {
          this.vx += Math.sin(this.y * 0.009 + t * 0.001) * (0.03 + turbulence * 0.06);
          this.vy += Math.cos(this.x * 0.009 + t * 0.001) * (0.03 + turbulence * 0.06);
        }

        if (mouse.active && fsm.state !== 'NIRODHA') {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const dist = Math.max(1, Math.hypot(dx, dy));
          if (dist < 280) {
            const force = ((280 - dist) / 280) * 0.45;
            this.vx += (dx / dist) * force;
            this.vy += (dy / dist) * force;
            fsm.entropy = clamp(fsm.entropy + 0.03, 0, 100);
          }
        }

        this.vx *= 0.94;
        this.vy *= 0.94;
        this.x += this.vx * speed;
        this.y += this.vy * speed;

        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = palette[fsm.state] || palette.IDLE;
        ctx.globalAlpha = fsm.state === 'NIRODHA' ? 0.28 : 0.45 + Math.sin(Date.now() * 0.006) * 0.15;
        ctx.fill();
      }
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function evolveState() {
      if (fsm.state === 'NIRODHA') {
        fsm.energy = clamp(fsm.energy + 0.28, 0, 100);
        fsm.load = clamp(fsm.load - 0.18, 0, 100);
        fsm.entropy = clamp(fsm.entropy - 0.2, 0, 100);
        if (fsm.energy > 96) fsm.state = 'IDLE';
        return;
      }

      fsm.energy = clamp(fsm.energy - 0.045 - fsm.energyLevel * 0.03, 0, 100);
      fsm.entropy = clamp(fsm.entropy * 0.996, 0, 100);
      fsm.load = clamp(fsm.load * 0.994, 0, 100);

      if (fsm.energy < 10 || fsm.load > 92) {
        fsm.state = 'CRITICAL';
      } else if (fsm.energy < 18) {
        fsm.state = 'DECAY';
      } else if (fsm.load > 65) {
        fsm.state = 'RESONATING';
      } else if (fsm.entropy > 45) {
        fsm.state = 'PROCESSING';
      } else {
        fsm.state = 'IDLE';
      }

      if (fsm.energy <= 1) fsm.state = 'NIRODHA';
    }

    function inferIntentVector(text) {
      const t = text.toLowerCase();
      let intentCategory = 'chat';
      if (/^(run|execute|deploy|start|stop|สั่ง|ทำ)/.test(t)) intentCategory = 'command';
      if (/(สรุป|explain|what|หา|ค้น|ข้อมูล|request|ช่วยหา)/.test(t)) intentCategory = 'request';
      if (/(error|ผิด|พัง|fail|broken)/.test(t)) intentCategory = 'error';

      let emotionalValence = 0;
      if (/(ดีใจ|great|awesome|thanks|ขอบคุณ)/.test(t)) emotionalValence = 0.65;
      if (/(เครียด|angry|sad|confused|tired|เหนื่อย|งง)/.test(t)) emotionalValence = -0.65;

      const urgent = /(ด่วน|urgent|now|asap|ทันที|เร็ว)/.test(t);
      const energyLevel = clamp((text.length / 120) + (urgent ? 0.36 : 0.08), 0, 1);

      const concepts = [];
      if (/(fire|heat|hot|แดง|วิกฤต)/.test(t)) concepts.push('fire');
      if (/(flow|water|stream|ไหล)/.test(t)) concepts.push('flow');
      if (/(structure|table|schema|json|order|ระเบียบ)/.test(t)) concepts.push('structure');
      if (/(mountain|ภูเขา|hill)/.test(t)) concepts.push('mountain');
      if (/(river|แม่น้ำ|waterfall)/.test(t)) concepts.push('river');
      if (/(human|มนุษย์|body|ร่างกาย)/.test(t)) concepts.push('human');
      if (/(face|ใบหน้า|portrait)/.test(t)) concepts.push('face');
      if (concepts.length === 0) concepts.push('balance');

      let baseShape = 'sphere';
      if (intentCategory === 'error') baseShape = 'cracks';
      else if (concepts.includes('mountain')) baseShape = 'mountain';
      else if (concepts.includes('river')) baseShape = 'river';
      else if (concepts.includes('face')) baseShape = 'face';
      else if (concepts.includes('human')) baseShape = 'human';
      else if (concepts.includes('flow')) baseShape = 'vortex';
      else if (concepts.includes('structure')) baseShape = 'cube';
      else if (energyLevel < 0.25) baseShape = 'cloud';

      return {
        intent_category: intentCategory,
        emotional_valence: Number(emotionalValence.toFixed(2)),
        energy_level: Number(energyLevel.toFixed(2)),
        semantic_concepts: concepts,
        visual_parameters: {
          base_shape: baseShape,
          turbulence: Number(clamp(0.1 + energyLevel * 0.8, 0, 1).toFixed(2)),
          particle_density: Number(clamp(0.35 + energyLevel * 0.55, 0, 1).toFixed(2))
        }
      };
    }

    function applyIntent(vector) {
      fsm.intentCategory = vector.intent_category;
      fsm.energyLevel = vector.energy_level;
      fsm.turbulence = vector.visual_parameters.turbulence;
      fsm.particleDensity = vector.visual_parameters.particle_density;
      fsm.emotionalValence = vector.emotional_valence;
      fsm.desiredForm = vector.visual_parameters.base_shape;
      fsm.load = clamp(fsm.load + vector.energy_level * 38, 0, 100);
      fsm.entropy = clamp(fsm.entropy + vector.energy_level * 26, 0, 100);
      fsm.energy = clamp(fsm.energy - vector.energy_level * 9, 0, 100);
      fsm.state = 'PROCESSING';

      if (vector.visual_parameters.base_shape === 'cracks') {
        fsm.shape = 'cloud';
        fsm.state = 'CRITICAL';
      } else {
        fsm.shape = vector.visual_parameters.base_shape;
      }

      const targetCount = Math.floor(220 + fsm.particleDensity * 980);
      particles = Array.from({ length: targetCount }, () => new Particle());

      refs.json.textContent = JSON.stringify(vector, null, 2);
    }

    function addBubble(role, message) {
      const p = document.createElement('p');
      p.className = `bubble ${role}`;
      p.textContent = `${role === 'user' ? 'USER' : 'SYSTEM'}: ${message}`;
      refs.chatStream.prepend(p);
      while (refs.chatStream.children.length > 10) refs.chatStream.removeChild(refs.chatStream.lastChild);
    }

    async function fetchReferenceSignals(text) {
      const q = encodeURIComponent(text.trim().slice(0, 80));
      if (!q) return [];
      try {
        const api = `https://en.wikipedia.org/w/api.php?action=opensearch&search=${q}&limit=3&namespace=0&format=json&origin=*`;
        const res = await fetch(api);
        if (!res.ok) return [];
        const data = await res.json();
        const titles = (data && data[1]) || [];
        return titles.filter(Boolean).slice(0, 3);
      } catch (_) {
        return [];
      }
    }

    async function processUserInput(text) {
      addBubble('user', text);
      fsm.state = 'LISTENING';
      const references = await fetchReferenceSignals(text);
      fsm.sourceHints = references;
      refs.sources.textContent = references.length
        ? `sources: ${references.join(' | ')}`
        : 'sources: none (offline/no match)';

      const enriched = references.length ? `${text} ${references.join(' ')}` : text;
      const vector = inferIntentVector(enriched);
      applyIntent(vector);

      const response = `understood intent=${vector.intent_category}, form=${vector.visual_parameters.base_shape}, refs=${references.length}`;
      addBubble('system', response);
    }

    function renderHUD() {
      refs.stateText.textContent = fsm.state;
      refs.energyText.textContent = `${Math.round(fsm.energy)}%`;
      refs.entropyText.textContent = `${Math.round(fsm.entropy)}%`;
      refs.loadText.textContent = `${Math.round(fsm.load)}%`;

      refs.energyBar.style.width = `${fsm.energy}%`;
      refs.entropyBar.style.width = `${fsm.entropy}%`;
      refs.loadBar.style.width = `${fsm.load}%`;

      refs.energyBar.style.backgroundColor = palette[fsm.state] || palette.IDLE;
      refs.entropyBar.style.backgroundColor = '#00ffff';
      refs.loadBar.style.backgroundColor = fsm.load > 65 ? '#ffd700' : '#ffffff';

      refs.shapeChip.textContent = `shape: ${fsm.shape}`;
      refs.intentChip.textContent = `intent: ${fsm.intentCategory}`;

      refs.status.classList.toggle('critical', fsm.state === 'CRITICAL');
      refs.compatNote.textContent = compatMode
        ? 'mode: compatibility (deterministic SVG snapshots every 500ms)'
        : 'mode: realtime';
    }

    function renderCompatFrame() {
      const stroke = palette[fsm.state] || palette.IDLE;
      const energy = Math.round(fsm.energy);
      const entropy = Math.round(fsm.entropy);
      const load = Math.round(fsm.load);

      const svg = `
<svg xmlns='http://www.w3.org/2000/svg' width='640' height='180' viewBox='0 0 640 180'>
  <rect width='640' height='180' fill='#050505'/>
  <text x='16' y='26' fill='#ffffff' font-size='14' font-family='monospace'>AETHERIUM COMPAT FRAME</text>
  <text x='16' y='48' fill='${stroke}' font-size='13' font-family='monospace'>STATE: ${fsm.state}</text>
  <rect x='16' y='64' width='608' height='10' fill='#222'/>
  <rect x='16' y='64' width='${(608 * energy) / 100}' height='10' fill='${stroke}'/>
  <text x='16' y='90' fill='#00ffff' font-size='12' font-family='monospace'>ENERGY ${energy}%</text>
  <text x='180' y='90' fill='#00ffff' font-size='12' font-family='monospace'>ENTROPY ${entropy}%</text>
  <text x='360' y='90' fill='#ffd700' font-size='12' font-family='monospace'>LOAD ${load}%</text>
  <text x='16' y='116' fill='#cccccc' font-size='12' font-family='monospace'>shape=${fsm.shape} intent=${fsm.intentCategory}</text>
  <circle cx='580' cy='112' r='18' fill='none' stroke='${stroke}' stroke-width='2'/>
  <circle cx='580' cy='112' r='${4 + (fsm.energyLevel * 12)}' fill='${stroke}' opacity='0.7'/>
  <text x='16' y='144' fill='#9db5ff' font-size='11' font-family='monospace'>Designed for low-feature / unstable headless environments.</text>
</svg>`;
      refs.compatFrame.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
    }

    function detectCompatibilityMode() {
      const params = new URLSearchParams(window.location.search);
      const forceCompat = params.get('render') === 'compat';
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      compatMode = Boolean(forceCompat || reduceMotion);
      if (compatMode) {
        fsm.shape = 'sphere';
        fsm.turbulence = 0.08;
      }
    }

    function drawBackground() {
      ctx.fillStyle = 'rgba(5,5,8,0.24)';
      ctx.fillRect(0, 0, width, height);

      if (fsm.state === 'NIRODHA') {
        ctx.fillStyle = 'rgba(0, 0, 139, 0.06)';
        ctx.fillRect(0, 0, width, height);
      }
    }

    function tick(t) {
      drawBackground();
      evolveState();

      if (!compatMode) {
        for (const p of particles) {
          p.update(t);
          p.draw();
        }
      } else if (t - compatLastFrameAt > 500) {
        renderCompatFrame();
        compatLastFrameAt = t;
      }

      ctx.globalAlpha = 1;
      renderHUD();
      requestAnimationFrame(tick);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => {
      mouse.active = true;
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      fsm.energy = clamp(fsm.energy - 0.02, 0, 100);
      fsm.entropy = clamp(fsm.entropy + 0.03, 0, 100);
    });

    document.getElementById('send-btn').addEventListener('click', async () => {
      const input = document.getElementById('intent-input');
      const text = input.value.trim();
      if (!text) return;
      await processUserInput(text);
      input.value = '';
    });

    document.getElementById('intent-input').addEventListener('keydown', e => {
      if (e.key === 'Enter') document.getElementById('send-btn').click();
    });


    refs.settingsToggle.addEventListener('click', () => {
      document.body.classList.toggle('ui-open');
    });

    refs.chatToggle.addEventListener('click', () => {
      document.body.classList.toggle('chat-open');
    });

    document.getElementById('nirodha-btn').addEventListener('click', () => {
      fsm.state = 'NIRODHA';
      fsm.shape = 'cloud';
      fsm.intentCategory = 'maintenance';
      fsm.energyLevel = 0.05;
      fsm.turbulence = 0.08;
      refs.json.textContent = JSON.stringify({
        intent_category: 'maintenance',
        emotional_valence: 0,
        energy_level: 0.05,
        semantic_concepts: ['calm', 'potentiality'],
        visual_parameters: { base_shape: 'cloud', turbulence: 0.08, particle_density: 0.38 }
      }, null, 2);
    });

    document.body.classList.remove('ui-open');
    document.body.classList.remove('chat-open');
    resize();
    detectCompatibilityMode();
    particles = Array.from({ length: 560 }, () => new Particle());
    renderCompatFrame();
    renderHUD();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
